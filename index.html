<html>
    <head>
        <title>Customization Guide</title>
         <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <p>this area for comments because it may be used for other purposes in the future.)
When using the CPTBL command, the name of the file that contains the code point
definitions does not have to be one of the predefined names. The NetView
program uses this control entry to determine the table type.</p>
        <p>The format of each subsequent entry in the code point table is:<br> <ul> <li>Columns 1–4 contain the 4-character hexadecimal code point number. Valid
characters are 0–9 and A–F. The code point range from X'E000' to X'EFFF' is
reserved for your use. To use code points outside this range, contact the Tivoli
        Support Center.</li><br> If a code point is defined more than once in a given table, the first entry is used,
subsequent entries are ignored, and an informational message is generated.<br> <li>Column 6 contains the embed flag (Y) indicating that qualifier data associated
with the X'82', X'83', or X'85' subfield is placed before the code point's text,
embedded within the code point's text, or follows on the same line after the
code point's text. Any character other than Y indicates that the embed flag is off.
If the embed flag is turned on, the embed information included in the generic
alert is embedded at the point marked by a dollar sign ($). Embedded text is
only supported for BNJ81TBL, BNJ86TBL, BNJ94TBL, BNJ95TBL, and BNJ96TBL.
Because no variable substitution is allowed for probable cause and alert
        description, an embed flag is ignored in BNJ92TBL and BNJ93TBL.<br></li> <li>Columns 8–72 contain the text description for this code point. The maximum
        length of the text varies as follows:<br></li> – Probable cause: 40 characters for the first entry of a given code point, 20 for
the second. (See ▌4▐ in “Example of BNJ92TBL Code Points Table” on page
102 for an explanation of the second entry.)<br> – Alert description: 40 characters for the first entry of a given code point, 25 for
the second. (See ▌4▐ in “Example of BNJ92TBL Code Points Table” on page
102 for an explanation of the second entry.)<br> – Detail data: 40 characters <br>– Others: 108 characters.<br>
        Start in column 2 when continuing the text on the next line.<br> <li> Columns 73–80 are ignored and can be used for optional sequence numbers.</li></ul>
        </p>
        <h3>Note</h3>
    <ol>
        <li>Code points in table BNJ82TBL must be left-justified and padded with zeros.
For example, you enter code point 12 as 1200.</li>
        <li>The text for the code point entries added to the NetView BNJ81TBL code point
table should begin with Ennn. The text for the code point entries added to the
NetView BNJ86TBL code point table should begin with Rnnn. The use of Ennn
and Rnnn allows the code points to be supported by the ACTION command
list (for more information on the ACTION command list, refer to the NetViewonline help). The action text in BNJ81TBL and BNJ86TBL should begin this way. Otherwise, when BNJDNUMB is used to generate recommended action
numbers, it overlays the first 4 bytes of the recommended action text.</li>
        <li>The hardware monitor searches the tables for the specific code points. If a
match is not found, the hardware monitor searches some tables for a general
code point.
A general code point is the code point with the last 2 bytes set to zero. For
example, if the specific code point is 1620, the general code point is 1600. If a
general code point is found, its text is returned as if it matched the original
code point. A general code point contains text that is valid for all specific code</li>
        <li>All code point tables are in uppercase. However, if you want to enter your own
code in lowercase or mixed case, the NetView program does not convert the
text to uppercase.</li>
    </ol>
    <h3><b>Use of %INCLUDE Statements</b></h3>
    <p>The use of %INCLUDE statements in the code points tables allows you to organize
your code points information for easier maintainability.<br> You can choose to have one main table for each code point type. This table can
contain the code points shipped with the NetView program and %INCLUDE
statements for user-defined subtables and subtables defined by other products.<br>
BNJxxTBL (where xx is the table number) are tables Tivoli does not recommend
modifying. Use these tables as main tables for each code point. If customization of
these tables is required, use the BNJxxUTB (where xx is the table number) file
which is included by the main table (BNJxxTBL) for this purpose.</p>
    <h3><b>Example of BNJ92TBL Code Points Table</b></h3>
    <p>An example of a code points table is shown in “Sample of BNJ92TBL Code Points
Table.” Explanations of the numeric references follow the figure.</p>
    <h3><b>Sample of BNJ92TBL Code Points Table</b></h3>
    <p>* An asterisk in column 1 indicates a comment line.<br>
* The following line is the control entry indicating table type.<br>
▌1▐92<br>
* Blank lines are allowed for readability.<br>
▌2▐%INCLUDE BNJ92UTB<br>
▌3▐ ▌4▐<br>
0100 SIMPLE CODE POINT TEXT;<br>
▌5▐E123 THIS TEXT IS EXACTLY FORTY CHARS LONG XX;<br>
E123 THIS IS THE SAME IN 25 XX;<br>
▌6▐FFFF<br>
▌1▐ The first non-comment line is the control entry.<br> ▌2▐ Code point tables can use %INCLUDE statements to embed other files into the
code point table.<br>
▌3▐ The code point (0100) is a 4-character hexadecimal number, starting in column<br>
1.<br>
▌4▐ The text description in columns 8–72 appears on the hardware monitor
displays.<br>
▌5▐ The hardware monitor has different panel formats that allow different length
text for alert descriptions (92) and probable causes (93). The maximum length of
the text for either entry is 40 characters. Abbreviated text is required, if the text
exceeds 25 characters for alert descriptions or 20 characters for probable causes.
Errors occur for text entries greater than 40 characters.<br>
▌6▐ Any entries in the table with code point FFFF and no text are ignored (to allowfor migration). Entries with code point FFFF and text are treated as any other code
point.</p>
    <h3><b>Example of BNJ94TBL Code Points Table</b></h3>
    <p>Another example of a code points table is shown in “Sample of BNJ94TBL Code
Points Table.”</p>
    <h3><b>Sample of BNJ94TBL Code Points Table</b></h3>
    <p>* An asterisk in column 1 indicates a comment line.<br>
* The following line is the control entry indicating table type.<br>
94<br>
▌1▐%INCLUDE BNJ94UTB<br>
2 0100 Y CODE POINTS TEXT WITH DETAIL INSERTS $ AND $<br>
▌3▐0200 CODE POINTS TEXT ILLUSTRATING CONTINUATION OF THE TEXT TO A SECON<br>
D LINE<br>
▌4▐0100 DUPLICATE TEXT<br>
▌1▐ Code point tables can use %INCLUDE statements to embed other files into the
code point table.<br>
▌2▐ The embed flag (Y in column 6) indicates that qualifier data is embedded at the
point marked by a dollar sign ($).<br>
▌3▐ Start in column 2 when continuing text on the next line. The text on the first
line starts in column 8 and continues through column 72.<br>
▌4▐ Because this code point has already been defined in the table, this entry is
ignored and an informational message is generated.</p>
    <h3><b>Activating the Modified Code Point Tables</b></h3>
    <p>The CPTBL command is very similar to the AUTOTBL command and is used to
dynamically activate changes made to code point tables after the NetView programis initialized (for a description of the CPTBL command, refer to NetView online
help). Use the TEST option on the CPTBL command to verify the syntax of a code
point table before activation.</p>
    <h3><b>Adding or Modifying Resource Types</b></h3>
    <p>You can add new resource types for hierarchical displays in the hardware monitor
by modifying the member BNJRESTY.<br> BNJRESTY is a member of the data set NETVIEW.V6R2M1.BNJPNL2, defined by
the definition statement BNJPNL2 in the NetView start procedure.<br>
“Sample Contents of BNJRESTY” shows the format for BNJRESTY. Explanations of
the numeric references follow the figure.
</p>
    <h3><b>Sample Contents of BNJRESTY</b></h3>
    <p>▌1▐ ▌2▐▌3▐<br>
10 DISK your comments<br>
▌1▐ A 2-character hexadecimal number, starting in column 1, flows to the NetViewprogram in the X'05' subvector. Valid characters are 0–9 and A–F. If you include
duplicate hexadecimal codes, the system uses the first entry of the duplicated code.
Numbers from X'E0' to X'EF' are reserved for customer-defined resource types.<br>
▌2▐ The four characters in columns 4–7 are taken as the resource type. Valid
characters are 0–9, A–Z, and any printable special characters. A resource type of less than 4 characters must begin in column 4, and be padded on the right with
blanks. Do not use delimiters, such as a comma (,), period (.), or equal sign (=), as
characters in the resource type.<br>
▌3▐ An optional comment can begin anywhere after the resource type.<br>
If BNJRESTY is modified while the hardware monitor task BNJDSERV is active, the
new resource types are not recognized. Use STOP TASK=BNJDSERV followed by
STARTCNM NPDA so that the NetView program can recognize any new resource
types or use the RTTBL command to activate a modified BNJRESTY member.<br> If the NetView program finds an entry that is not valid in BNJRESTY during
activation of the NetView program or when the RTTBL command is invoked, an
error message appears on the command facility console and the NetView programuses the resource types that are supplied by IBM.</p>
<div class="line"></div>
    <h2><b>Chapter 7. Modifying Network Asset Management CommandLists</b></h2>
    <p>Network asset management provides a way of collecting inventory data from a
subset of hardware and software devices automatically. You can use network asset
management to collect vital product data (VPD) such as serial numbers, machine
types, and model numbers for hardware products and software information. This
information includes version and release levels. However, the NetView programdoes not verify the returned data from devices supporting network asset
management; it only provides a way to collect and log the data.</p>
   <p><b>References:</b>Refer to the IBM Tivoli NetView for z/OS Administration Reference for
information on the record formats. Refer to the NetView online help for
information about the command lists that are provided with the NetView program.</p>
    <p>Any device that supports the REQUEST/REPLY PSID architecture can report VPDto the NetView program. An attempt to solicit VPD from a device that does not
support the architecture can cause the keyboard to lock or extraneous data to
appear on the screen. You may need to press the RESET key or clear the screen,
but these actions do not affect the VPD collection in the NetView program.<br>
        <b>Reference:</b> Refer to the SNA library for information on the REQUEST/REPLY
PSID architecture.<br>
The following examples are some physical units (PUs) that support the
REQUEST/REPLY PSID architecture: </p>
    <ul>
        <li>3720/NCP</li>
        <li>3725/NCP</li>
        <li>3745/NCP</li>
        <li>3174 that reports data for itself and many types of attached devices such as
various models of 3191, 3192, and 3194 display stations.</li></ul>
        <p>Personal computers running OS/2 are required with these products.<br>
            <b>Reference:</b> Instructions for entering VPD for a device are located in the user's
guides for that device.<br>
Network asset management provides the VPDCMD command to solicit VPD froma given device and the VPDLOG command to build and log a record to an external
logging facility (such as SMF). You can use Service Level Reporter (SLR) to viewthe data interactively or to generate reports, or the VPDALL command to generate
VPDPU and VPDDCE command entries for all devices within a NetView domain.
If you have any resources that require switched lines, be sure that the switched
lines are active before collecting VPD.<br>Network asset management provides the following command lists:</p>
       <h3> VPDPU</h3>
        <p class="pad">Collects and logs VPD from a single PU and its attached devices. You can
enter this command list from an operator's console or from another
command list.</p>
    <h3>VPPDCE</h3>
    <p class="pad">Solicits and logs VPD from DCEs that are in a direct path between a
specified NCP and a specified PU. You can issue this command list from
an operator's console or from another command list.</p>
    <h3>VPDACT</h3>
    <p class="pad">Is the default name of a command list that the VPDALL command
generates when issued with the CREATE option. VPDALL reads a VTAMconfiguration member in VTAMLST as input and generates a command list
called VPDACT (the default). VPDACT contains a list of VPDPU and
VPDDCE entries for devices in your domain. You can later issue VPDACT
to collect and log VPD from the supported devices in the NetView domain</p>
    <h3>VPDLOGC</h3>
    <p class="pad">Is the command list that builds and logs START and END records. A
START record is generated for a VPDACT command list at the beginning
of a VPD solicitation. An END record is generated for a VPDACT
command list at the end of a VPD solicitation. Do not issue this command
list from an operator's console or from a user-written command list.</p>
    <h3>VPDXDOM</h3>
    <p class="pad">Is a service command list used for VPD solicitation from cross-domain
resources. This command list is driven through a NetView automation
table. Do not issue this command list from an operator's console or from a
user-written command list.</p>
    <p><b>Reference:</b> Refer to <i>IBM Tivoli NetView for z/OS Administration Reference </i>for the
record formats and the NetView online help for descriptions of VPD command
lists. Refer to <i>IBM Tivoli NetView for z/OS Automation Guide</i> for additional
information.</p>
    <div class="line"></div>
    <h2><b>VPD Collection from a Single PU</b></h2>
    <p>The following list describes the procedures for collecting VPD from a single PU
and its attached devices:<br>
1. Specify a resource name and issue the VPDPU or VPDDCE command list.<br>
2. The command list issues a VPDCMD command to solicit data from the
specified resource, and waits for the response messages.<br>
3. A PU responds with VPD for itself, or for itself and its attached devices.<br>
4. The command list traps the response messages and saves the VPD, such as
machine type, model number, and serial numbers, in command list variables.<br>
5. When the completion message is received, the command list builds records and
writes them to an external logging facility.<br> 6. If any abnormal events occur before completion, a command list error message
is issued and the command list terminates. An abnormal event can be a logging
failure, an inactive VPDTASK, or an abend.</p>
    <div class="line"></div>
    <h2><b>VPD Collection from a Single NetView Domain</b></h2>
    <p>The following list describes procedures for collecting VPD from a single NetView
domain:<br>
1. A NetView operator enters the following command:
VPDALL CONFIG(ATCCON01),CREATE,CLIST(VPDACT),ADD<br>
2. The VPDALL command list reads the specified nodes from the configuration
member (ATCCON01, in this example) in VTAMLST. VPDALL extracts all the resource names from the VTAMLST nodes so that VPD can be collected.
VPDALL then builds VPDPU and VPDDCE entries in a command list called
VPDACT. VPDALL does not support dynamic reconfiguration decks (DRDs) or
DCEs on switched lines.
        <b>Note:</b> To collect data from the entire domain, the configuration member must
contain the definitions for all the resources in the domain.<br>
3. You can modify VPDACT by adding or deleting resource names.<br>
4. When the VPDACT command list is executed, VPDLOGC is called to generate
a START record. VPDACT then calls the VPDPU and VPDDCE command lists
and, after they are complete, calls the VPDLOGC to generate an END record.</p>
    <div class="line"></div>
    <h2><b>Focal Point VPD Collection</b></h2>
    <p>Figure 26 shows a focal point NetView program for VPD.</p>
    <center><img src="Screenshot%20(45).png"></center>
    <p><i>Figure 26. VPD Focal Point NetView Program</i></p>
    <p>The following steps describe the procedures for the collection of VPD for the
sample focal point NetView program shown in Figure 26.<br> 1. During installation, NV1 sets the common global variable SMFVPD to 200.
NV2 sets the common global variable to 250.<br>
        <b>Note:</b> CNMSTYLE sets the common global variable SMFVPD to 37.<br>
2. NV1 is designated as a focal point NetView program for VPD collection. In
the NetView automation table (DSITBL01), for NV1 only, uncomment the
statement designated to drive the VPDXDOM command list.
Reference: For more information, refer to the IBM Tivoli NetView for z/OS
Installation: Configuring Additional Components.<br> 3. Start DSIELTSK from the focal point NetView NV1.
4. NV1 establishes a direct OST-to-NNT session with NV2 using the START
DOMAIN command.<br>
5. NV1 issues START VPDTASK.<br>
6. NV1 issues ROUTE NV2, START VPDTASK.<br>
7. NV1 issues ROUTE NV2, VPDACT. This causes the VPDACT command list in
NV2 to run under an NNT.<br> 8. In NV2, VPDACT verifies that it is running under an NNT, and generates the
following message:<br>
MSG OPID X$S VPDLOG 250 ’1 STRING1 10 STRING2...’</p>
    <p>where X$S is a special string recognized by the NetView automation table.<br>
9. When the VPDACT command list in NV2 writes the generated message to the
operator in NV1, the message triggers the NetView automation table to
execute the VPDXDOM command list in NV1.<br>
        <b>Reference:</b> Refer to IBM Tivoli NetView for z/OS Automation Guide for
additional information about the VPXDOM command list.<br>
10. When VPDXDOM is entered, the message string is as follows:
DSI039I MSG FROM OPID : X$S VPDLOG 250 1 STRING1...<br>
11. VPDXDOM verifies that NV1 set SMFVPD as a common global variable and
changes SMFVPD from 250 (NV2) to 200 (NV1).<br>
12. VPDLOGC logs the data records under NV1's SMF record number 200.<br>
13. Be sure that the cross-domain session stays active until after the VPD
solicitation is completed.</p>
    <div class="line"></div>
    <h2><b>Customization Considerations</b></h2>
    <p>You can customize the VPD command lists that are provided with the NetView
program to suit your requirements.<br>
When modifying network asset management command lists to build different
record formats, do not exceed 256 bytes per record. The NetView program has a
command string limitation of 240 characters. You can write a command processor
to make full use of the VPD command.<br>
        <b>Reference:</b> Refer to<i> IBM Tivoli NetView for z/OS Programming: Assembler</i> for
information about command processors.<br>
If you are changing the SMF record format, you cannot use record number 37. You
must globally define the SMF record number within the user-defined range of
128–255. If you are using SLR, you must write the SLR table to match your
modified SMF record format.<br>
        <b>Reference:</b> Refer to NetView online help and<i> IBM Tivoli NetView for z/OS
        Programming: REXX and the NetView Command List Language </i>for limitations on the
use of &WAIT and RESET, and for considerations regarding the issuance of a
second network asset management command list and network asset management
command while a previous network asset management command list is running.<br>
To improve performance, you can do the following:</p>
    <ul>
        <li>v Write a command list that reads in VPDACT to distribute the workload among
several autotasks. Dividing the workload among several OSTs or autotasks
allows multiple VPDPU or VPDDCE entries to execute simultaneously. Otherwise, the VPDPU and VPDDCE entries are executed serially.</li>
        <li>Create several configuration members (for example, one member for each major
node) or, using VPDALL, create several command lists.</li>
        <li>v Make each command list run under several tasks, such as an OST and an
autotask.</li>
    </ul>
    <div class="line"></div>
    <h2><b>Chapter 8. Customizing the Event/Automation Service</b></h2>
    <hr>
    <h3><b>Event/Automation Service: Overview</b></h3>
    <p>The Event/Automation Service consists of the following services:</p>
    <ul>
        <li>v Alert adapter service<br>
The alert adapter service is an event adapter that converts NetView for z/OS
alerts to Event Integration Facility (EIF) events and forwards the events to a
designated event server. The alert adapter service collects filtered SNA alerts
directly from the NetView hardware monitor and translates the alerts into
appropriate event class or subclass instances. To receive alerts from the NetViewprogram, the Event/Automation Service registers with the NetView PPI. Filtered
alerts from the NetView hardware monitor are sent over the PPI to the alert
adapter service. All alerts to be converted will match the formats described in
            the<i> IBM Systems Network Architecture Management Services Reference.</i></li>
    </ul>
    <li>Confirmed alert adapter service<br>
The confirmed alert adapter service is an event adapter that converts NetViewfor z/OS alerts to EIF events. The resulting events are forwarded to a designated
event server. The event server then replies with a confirmation that indicates
acceptance of the EIF event.<br>
The confirmed alert adapter service collects filtered SNA alerts directly from the
NetView hardware monitor and translates the alerts into appropriate event class
or subclass instances. To receive alerts from the NetView program, the
Event/Automation Service registers with the NetView PPI. Filtered alerts fromthe NetView hardware monitor are sent over the PPI to the confirmed alert
adapter service. The confirmation expected by the adapter is described in a note
in the sample class definition statement file IHSABCDS for the confirmed alert
adapter. All alerts to be converted match the formats that are described in the
        <i>IBM Systems Network Architecture Management Services Reference.</i></li>
    <li>Message adapter service<br>
The message adapter service is an event adapter that converts any message
forwarded from NetView message automation into EIF events. The resulting
events are forwarded to a designated event server. The message adapter collects
filtered messages directly from the NetView automation table and translates the
messages into appropriate event class or subclass instances. To receive messages
from the NetView program, the Event/Automation Service registers with the
NetView PPI. Filtered messages from the NetView message automation table are
sent over the PPI to the message adapter.</li>
    <li>Confirmed message adapter service<br>
The confirmed message adapter service is an event adapter that converts any
message forwarded from NetView message automation into EIF events. The
resulting events are forwarded to a designated event server. The event server
then replies with a confirmation that indicates acceptance of the EIF event. The
confirmation expected by the adapter is described in a note in the sample
message format file IHSANFMT for the confirmed message adapter.The confirmed message adapter collects filtered messages directly from the
NetView automation table and translates the messages into appropriate event
class or subclass instances. To receive messages from the NetView program, the
Event/Automation Service registers with the NetView PPI. Filtered messages
from the NetView message automation table are sent over the PPI to the
confirmed message adapter</li>
    <li>Event receiver service<br>
The event receiver service receives events from an event server and converts
them into SNA alerts. The converted alerts are then forwarded to the NetView
hardware monitor where they are filtered and routed to the NetView automation
table.</li>
    <li>Alert-to-trap service<br>
The alert-to-trap service is an SNMP sub-agent that converts NetView for z/OS
alerts to SNMP traps and forwards the traps to an SNMP agent. The alert-to-trap
service collects filtered SNA alerts directly from the NetView hardware monitor
and translates the alerts into appropriate SNMP trap instances. To receive alerts
from the NetView program, the Event/Automation Service registers with the
NetView PPI. Filtered alerts from the NetView hardware monitor are sent over
the PPI to the alert-to-trap service. All alerts to be converted match the formats
that are described in the<i> IBM Systems Network Architecture Management Services
        Reference.</i></li>
    <li>Trap-to-alert service<br>
The trap-to-alert service receives events from an SNMP manager and converts
them into SNA alerts. The converted alerts are then forwarded to the NetView
hardware monitor where they are filtered and routed to the NetView automation
table.</li>
    <div class="sline"></div>
    <h3><b>Starting the Event/Automation Service</b></h3>
    <p>The Event/Automation Service (E/AS) can be started from either the MVS systemconsole using a startup procedure, or from the UNIX System Services command
shell using a command file. The sample startup procedure installed with the E/AS
is IHSAEVNT. The command file used to start the E/AS from the UNIX System
Services command shell is IHSAC000.<br>
The environment that the E/AS is started from (either the MVS system console or
the UNIX System Services command shell) determines certain operational
characteristics of the E/AS as follows:<br></p>
    <ul><li>The location of default configuration files</li>
    <li>Whether certain startup parameters can be specified.</li>
    <li>The default output logs for trace/error data.</li></ul>
    <p>All other operational characteristics of the E/AS are the same regardless of the
startup environment.<br>
For information about installing and starting the E/AS, see the <i>IBM Tivoli NetView
        for z/OS Installation: Configuring Additional Components.</i> </p>
    <h2><b>Customizing the Initialization of the Event/Automation Service</b></h2>
    <p>The Event/Automation Service (E/AS) has a number of configurable settings. A
few must be set by the E/AS administrator in order for the E/AS to successfully
initialize. For more information, refer to<i> IBM Tivoli NetView for z/OS Installation:
        Configuring Additional Components.</i><br>Configurable settings can be set by the E/AS administrator using configuration
files, startup parameters, and E/AS modification commands. Some configurable
settings can be set using more than one of these methods. Configurable settings are
set in the following order, from highest priority to lowest:</p>
    <ul>
        <li>E/AS modification commands are issued to the E/AS after initialization. Any
E/AS modification commands that affect a configurable setting change that
setting for the duration of the current execution of the E/AS only.</li>
        <li>A configurable setting that is specified as an E/AS startup parameter.</li>
        <li>A configurable setting that is specified in a configuration file.</li>
        <li>v The default value of the configurable setting.</li>
        <p>E/AS modification commands are discussed fully in the <i>IBM Tivoli NetView for
            z/OS Command Reference Volume 1 (A-N).</i></p>
    </ul>
    <h2><b>Defaults for Configurable Settings</b></h2>
    <center><p>The following table lists all configurable settings and their defaults:</p></center>
    <table>
        <tr>
            <th>Settings</th>
            <th>Default</th>
            <th>Overridden by</th>
        </tr>
        <tr>
            <td>E/AS PPI name</td>
            <td>IHSATEC</td>
            <td>PPI startup parameter, global
initialization file PPI statement</td>
        </tr>
        <tr>
            <td>Global initialization file name</td>
            <td> Started with IHSAEVNT - IHSAINIT
Started with IHSAC000
--/etc/netview/global_init.conf</td>
            <td>IHSAINIT startup parameter</td>
        </tr>
        <tr>
            <td>Alert adapter configuration file name</td>
            <td>Started with IHSAEVNT -
IHSAACFG
Started with IHSAC000
--/etc/netview/alert_adpt.conf</td>
            <td>ALRTCFG startup parameter, global
initialization file ALRTCFG statement</td>
        </tr>
        <tr>
            <td>Confirmed alert adapter
configuration file name</td>
            <td>Started with IHSAEVNT -
IHSABCFG
Started with IHSAC000
--/etc/netview/
confirm_alert_adpt.conf</td>
            <td>CALRTCFG or -b startup parameter, global initialization file CALRTCFG
statement</td>
        </tr>
        <tr>
            <td>Alert-to-trap configuration file name</td>
            <td>Started with IHSAEVNT -
IHSAATCF
Started with IHSAC000
--/etc/netview/alert_trap.conf</td>
            <td>ALRTTCFG startup parameter, global
initialization file ALRTTCFG
statement</td>
        </tr>
        <tr>
            <td>Trap-to-alert configuration file name</td>
            <td>Started with IHSAEVNT - IHSATCFG
Started with IHSAC000
--/etc/netview/trap_alert.conf</td>
            <td>TALRTCFG startup parameter, global
initialization file TALRTCFG
statement</td>
        </tr>
        <tr>
            <td>Message adapter configuration file name</td>
            <td>Started with IHSAEVNT -
IHSAMCFG
Started with IHSAC000
--/etc/netview/message_adpt.conf</td>
            <td>MSGCFG startup parameter, global
initialization file MSGCFG statement</td>
        </tr>
        <tr>
            <td>Confirmed message adapter
configuration file name</td>
            <td>Started with IHSAEVNT -
IHSANCFG
Started with IHSAC000
--/etc/netview/
confirm_message_adpt.conf</td>
            <td>CMSGCFG or -n startup parameter, global initialization file CMSGCFG
statement</td>
        </tr>
        <tr>
            <td>Event receiver configuration file name</td>
            <td>Started with IHSAEVNT --
IHSAECFG
Started with IHSAC000
--/etc/netview/event_rcv.conf</td>
            <td>ERCVCFG startup parameter, global
initialization file ERCVCFG statement</td>
        </tr>
         <tr>
            <td>Output log wrapping</td>
            <td>0</td>
            <td>OUTSIZE startup parameter</td>
        </tr>
         <tr>
            <td>Disable console messages to the z/OS
UNIX System Services shell</td>
            <td>Enabled</td>
            <td>P startup option</td>
        </tr>
         <tr>
            <td>Console messages file name</td>
            <td>Started with IHSAEVNT --
IHSAMSG1
Started with IHSAC000 --
/usr/lpp/netview/msg/C/ihsamsg1</td>
            <td>m startup option</td>
        </tr>
         <tr>
            <td>Trace/error HFS path</td>
            <td>/tmp</td>
            <td>-E startup option</td>
        </tr>
         <tr>
            <td>Trace settings</td>
            <td>Off for all tasks</td>
            <td>Global initialization file TRACE
statement, TRACE command</td>
        </tr>
         <tr>
            <td>Service startup</td>
            <td>All services are started</td>
            <td>Global initialization file NOSTART
statement</td>
        </tr>
         <tr>
            <td>Trace/error data logical destination</td>
            <td>SYSOUT</td>
            <td>Global initialization file OUTPUT
statement, OUTPUT command</td>
        </tr>
         <tr>
            <td>Trace/error data logical destination</td>
            <td>No default</td>
            <td>Global initialization file OUTPUT
statement, OUTPUT command</td>
        </tr>
         <tr>
            <td>Event server port numbers</td>
            <td>For the confirmed alert adapter and
the confirmed message adapter the
default is 5539. For the alert adapter
and the message adapter, the default
value is 0.</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter file
ServerPort statement</td>
        </tr>
         <tr>
            <td>Alert adapter class definition
statement (CDS) file name</td>
            <td>Started with IHSAEVNT --
IHSAACDS
Started with IHSAC000
--/etc/netview/alert_adpt.cds</td>
            <td>Alert adapter configuration file
AdapterCdsFile statement</td>
        </tr>
         <tr>
            <td>Confirmed alert adapter class
definition statement (CDS) file name</td>
            <td>Started with IHSAEVNT --
IHSABCDS
Started with IHSAC000
--/etc/netview/
confirm_alert_adpt.cds</td>
            <td>Confirmed alert adapter
configuration file AdapterCdsFile
statement</td>
        </tr>
         <tr>
            <td>Alert-to-trap adapter class definition
statement (CDS) file name</td>
            <td>Started with IHSAEVNT --
IHSALCDS
Started with IHSAC000 --
/etc/netview/alert_trap.cds</td>
            <td>Alert-to-trap configuration file
AdapterCdsFile statement</td>
        </tr>
         <tr>
            <td>Trap-to-alert adapter class definition
statement (CDS) file name</td>
            <td>Started with IHSAEVNT --
IHSATCDS
Started with IHSAC000 --
/etc/netview/trap_alert.cds</td>
            <td>Trap-to-alert configuration file
AdapterCdsFile statement</td>
        </tr>
         <tr>
            <td>Event receiver class definition
statement file name</td>
            <td>Started with IHSAEVNT --
IHSAECDS
Started with IHSAC000
--/etc/netview/event_rcv.cds</td>
            <td>Event receiver configuration file
AdapterCdsFile statement</td>
        </tr>
         <tr>
            <td>Message adapter format file name</td>
            <td>Started with IHSAEVNT --
IHSAMFMT
Started with IHSAC000 --
/etc/netview/message_adpt.fmt</td>
            <td>Message adapter configuration file
AdapterFmtFile statement</td>
        </tr>
         <tr>
            <td>Confirmed message adapter format
file name</td>
            <td>Started with IHSAEVNT --
IHSANFMT
Started with IHSAC000 --
/etc/netview/
confirm_message_adpt.fmt</td>
            <td>Confirmed message adapter
configuration file AdapterFmtFile
statement</td>
        </tr>
         <tr>
            <td>Maximum event cache size</td>
            <td>64KB</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtMaxSize
statement</td>
        </tr>
         <tr>
            <td>Event cache HFS path</td>
            <td>/etc/Tivoli/tec/cache</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtMaxSize
statement</td>
        </tr>
         <tr>
            <td>Maximum event cache retrieval
buffer size</td>
            <td>64KB</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtMaxSize
statement</td>
        </tr>
        <tr>
            <td>Amount to shrink the event cache</td>
            <td>8KB</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtShrinkSize
statement</td>
        </tr>
        <tr>
            <td>Enable event buffering</td>
            <td>YES</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtShrinkSize
statement</td>
        </tr>
        <tr>
            <td>Rate to flush the event cache</td>
            <td>0</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtShrinkSize
statement</td>
        </tr>
        <tr>
            <td>Maximum number of events allowed
in the event cache</td>
            <td>0</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file BufEvtShrinkSize
statement</td>
        </tr>
        <tr>
            <td>Event server connection mode</td>
            <td>connection_less</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file ConnectionMode
statement</td>
        </tr>
        <tr>
            <td>Maximum size of an EIF event</td>
            <td>4096Bytes</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file ConnectionMode
statement</td>
        </tr>
        <tr>
            <td>EIF event filtering definitions</td>
            <td>No filters defined</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file Filter statement</td>
        </tr>
        <tr>
            <td>EIF event filtering from event cache
definitions</td>
            <td>No filters defined</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file Filter statement</td>
        </tr>
        <tr>
            <td>Mode of EIF event filtering</td>
            <td>OUT</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file Filter statement</td>
        </tr>
        <tr>
            <td>Broken connection retry interval and
time to wait for a response</td>
            <td>120 seconds</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file Filter statement</td>
        </tr>
        <tr>
            <td>Negative response limit</td>
            <td>0</td>
            <td>Confirmed alert adapter or confirmed
message adapter configuration file
BufEvtNegRespLimit statement</td>
        </tr>
        <tr>
            <td>EIF event forwarding debug mode</td>
            <td>NO</td>
            <td>Alert adapter, confirmed alert
adapter, message adapter, and
confirmed message adapter
configuration file TestMode statement</td>
        </tr>
        <tr>
            <td>Event receiver PPI name</td>
            <td>NETVALRT</td>Startup parameters can be specified for the IHSAEVNT startup procedure if you
are starting the E/AS from the MVS system console, or on the UNIX System
Services command line for the IHSAC000 command. Startup parameters follow
two general formats:
            <td>Event receiver configuration file
NetViewAlertReceiver statement</td>
        </tr>
        <tr>
            <td>Event receiver port number</td>
            <td>0</td>
            <td>Event receiver configuration file
NetViewAlertReceiver statement</td>
        </tr>
        <tr>
            <td>Enable PortMapper for the event receiver</td>
            <td>YES</td>
            <td>Event receiver configuration file
NetViewAlertReceiver statement</td>
        </tr>
        <tr>
            <td>Create a single SV31 from incoming
event data; truncation occurs if
necessary</td>
            <td>Yes</td>
            <td>Event receiver service and
trap-to-alert service configuration
files TruncateSV31s statement</td>
        </tr>
    </table>
    <h2><b>Customizing the Event/Automation Startup Parameters </b></h2>
    <p>Startup parameters can be specified for the IHSAEVNT startup procedure if you
are starting the E/AS from the MVS system console, or on the UNIX System
Services command line for the IHSAC000 command. Startup parameters follow
two general formats:</p>
    <ul><li>v parameter=value</li>
    <li>-option [value]</li></ul>
    <p>Either format can be used from either startup environment unless otherwise noted
in the information that follows. However, to pass the option/value format to the
IHSAEVNT startup procedure, the list of options and values must be encoded into
a single parameter/value format. The IHSAEVNT startup procedure provides the
following parameter to accomplish this:<br>
OELINE<br>
An example of using the OELINE parameter to pass option/value format startup
parameters to the IHSAEVNT startup procedure follows:
s IHSAEVNT,OELINE=’-opt1 value1 -opt2 value2...’<br> Use single quotes to surround the options and values passed with the OELINE
parameter.<br> The option/value format is a case-sensitive format. Ensure you specify the
following options exactly as they are described. Values are not translated to
uppercase. For some options, only the option is specified. There is no
corresponding value associated with the option.<br>
The startup parameters are:<br>
</p>
    <p><b>INITFILE=</b>file<b> or -i</b> file</p>
    <p class="pad">This startup parameter specifies the name of the global initialization file in
file. If you use the INITFILE=file format, the file is a 1–8 character PDS
member name that is associated with the IHSSMP3 data set definition fromthe IHSAEVNT startup procedure. This format is not valid when starting
the E/AS from the UNIX System Services command line. If you use the -i
file format, the file is a full MVS data set or HFS path and file name.
Surround MVS data set names with single quotes to make them
fully-qualified data sets. For example:<br>
INITFILE=IHSAINIT<br>
-i ’NETVIEW.V6R2M1.SCNMUXCL(IHSAINIT)’<br>
-i /etc/netview/global_init.conf</p>
    <p><b>MSGCFG</b>=file or <b>-m </b>file</p>
    <p class="pad">This startup parameter specifies the name of the message adapter
configuration file in file. If you use the MSGCFG=file format, the file is a
1–8 character PDS member name that is associated with the IHSSMP3 data set definition from the IHSAEVNT startup procedure. This format is not
allowed when starting the E/AS from the UNIX System Services command
line. If you use the -m file format, the file is a full MVS data set or HFS
path and file name. Surround MVS data set names with single quotes to
make them fully-qualified data sets. For example:<br>
MSGCFG=IHSAMCFG<br>
-m ’NETVIEW.V6R2M1.SCNMUXCL(IHSAMCFG)’<br>
-m /etc/netview/message_adpt.conf</p>
    <p><b>CMSGCFG=</b>file<b> or -n</b> file</p>
    <p class="pad">CFG=file or -n file
This startup parameter specifies the name of the confirmed message
adapter configuration file in file. If you use the CMSGCFG=file format, the
file is a 1 - 8 character PDS member name that is associated with the
IHSSMP3 data set definition from the IHSAEVNT startup procedure. This
format is not allowed when starting the Event/Automation Service from
the UNIX System Services command line. If you use the -n file format, the
file is a full MVS data set or HFS path and file name. Surround MVS data
set names with single quotation marks to make them fully-qualified data
sets. For example:<br>
CMSGCFG=IHSANCFG<br>
-n ’NETVIEW.V6R2M1.SCNMUXCL(IHSANCFG)’<br>
-n /etc/netview/confirm_message_adpt.conf</p>
    <p><b>ALRTCFG=</b>file <b>or -a</b> file</p>
    <p class="pad">This startup parameter specifies the name of the alert adapter
configuration file in file. If you use the ALRTCFG=file format, the file is a
1–8 character PDS member name that is associated with the IHSSMP3 data
set definition from the IHSAEVNT startup procedure. This format is not
allowed when starting the E/AS from the UNIX System Services command
line. If you use the -a file format, the file is a full MVS data set or HFS path
and file name. Surround MVS data set names with single quotes to make
them fully-qualified data sets. For example:<br>
ALRTCFG=IHSAACFG<br>
-a ’NETVIEW.V6R2M1.SCNMUXCL(IHSAACFG)’<br>
-a /etc/netview/alert_adpt.conf</p>
    <p><b>CALRTCFG=</b>file <b>or -b</b> file</p>
    <p class="pad">This startup parameter specifies the name of the confirmed alert adapter
configuration file in file. If you use the CALRTCFG=file format, the file is a
1 - 8 character PDS member name that is associated with the IHSSMP3
data set definition from the IHSAEVNT startup procedure. This format is
not allowed when starting the Event/Automation Service from the UNIX
System Services command line. If you use the -b file format, the file is a
full MVS data set or HFS path and file name. Surround MVS data set
names with single quotation marks to make them fully-qualified data sets.
For example:<br>
CALRTCFG=IHSABCFG<br>
-b ’NETVIEW.V6R2M1.SCNMUXCL(IHSABCFG)’<br>
-b /etc/netview/confirm_alert_adpt.conf</p>
    <p><b>ALRTTCFG=</b>file <b>or -a</b> file</p>
    <p class="pad">This startup parameter specifies the name of the alert-to-trap service
configuration file in file. If you use the ALRTTCFG=file format, the file is a
1–8 character PDS member name that is associated with the IHSSMP3 data
set definition from the IHSAEVNT startup procedure. This format is not
allowed when starting the E/AS from the UNIX System Services command
line. If you use the -a file format, the file is a full MVS data set or HFS path
and file name. Surround MVS data set names with single quotes to make
them fully-qualified data sets. For example:<br>
ALRTTCFG=IHSAATCF<br>
-l ’NETVIEW.V6R2M1.SCNMUXCL(IHSAATCF)’<br>
-l /etc/netview/alert_trap.conf</p>
    <p><b>TALRTCFG=</b>file<b> or -t</b> file</p>
    <p class="pad">This startup parameter specifies the name of the trap-to-alert service
configuration file in file. If you use the TALRTCFG=file format, the file is a
1–8 character PDS member name that is associated with the IHSSMP3 data
set definition from the IHSAEVNT startup procedure. This format is not
allowed when starting the E/AS from the UNIX System Services command
line. If you use the -t file format, the file is a full MVS data set or HFS path
and file name. Surround MVS data set names with single quotes to make
them fully-qualified data sets. For example:<br>
TALRTCFG=IHSATCFG<br>
-t ’NETVIEW.V6R2M1.SCNMUXCL(IHSATCFG)’<br>
-t /etc/netview/trap_alert.conf</p>
    <p><b>ERCVCFG=</b>file<b> or -e </b>file</p>
    <p class="pad">This startup parameter specifies the name of the event receiver
configuration file in file. If you use the ERCVCFG=file format, the file is a
1–8 character PDS member name that is associated with the IHSSMP3 data
set definition from the IHSAEVNT startup procedure. This format is not
allowed when starting the E/AS from the UNIX System Services command
line. If you use the -e file format, the file is a full MVS data set or HFS path
and file name. Surround MVS data set names with single quotes to make
them fully-qualified data sets. For example:<br>
ERCVCFG=IHSAECFG<br>
-e ’NETVIEW.V6R2M1.SCNMUXCL(IHSAECFG)’<br>
-e /etc/netview/event_rcv.conf</p>
    <p><b>PPI</b>=ppiname <b> or -p </b> ppiname</p>
    <p class="pad">This startup parameter specifies the name of the E/AS PPI mailbox in
ppiname. For example:<br>
PPI=IHSATEC<br>
-p IHSATEC</p>
    <p><b>OUTSIZE</b>=size <b> or -O  </b>size</p>
    <p class="pad">This startup parameter enables output log wrapping and specifies the
maximum size of the output log file, in kilobytes. If size is specified as 0,
output log wrapping is disabled. For more information about E/AS output,
see “Event/Automation Service Output” on page 118.<br>
OUTSIZE=0<br>
-O 0</p>
    <p><b>-M </b><i> msgfile</i></p>
    <p class="pad">This startup parameter specifies the location of the E/AS messages file.
msgfile specifies a full MVS data set or HFS path and filename. Surround
MVS data set names with single quotes to make them fully qualified data
sets. For example:<br>
-M ’NETVIEW.V6R2M1.SDUIMSG1(IHSAMSG1)’<br>
-M /usr/lpp/netview/msg/C/ihsamsg1</p>
    <p><b>-p</b></p>
    <p class="pad">This startup parameter is not allowed when starting the E/AS from the
IHSAEVNT startup procedure. It is used to disable the forwarding of MVS
system console messages to the UNIX System Services command shell if
the E/AS was started under the UNIX System Services command shell. By
default, a message that is issued to the MVS system console is also issued
at the UNIX System Services command shell.</p>
    <p><b>-E</b><i>path</i></p>
    <p class="pad">This startup parameter is not allowed when starting the E/AS from the
IHSAEVNT startup procedure. This startup parameter specifies the HFS
path of trace/error log files. path specifies an HFS path. For example:<br>
-E /tmp</p>
    <h2><b>Customizing the Event/Automation Service Configuration Files</b></h2>
    <ul><li>The global initialization file<br>
IHSAINIT or /etc/netview/global_init.conf</li>
    <li>v The alert adapter configuration file<br>
IHSAACFG or /etc/netview/alert_adpt.conf</li>
        <li>The confirmed alert adapter configuration file<br>
IHSABCFG or /etc/netview/confirm_alert_adpt.conf</li>
        <li>The alert-to-trap service configuration file<br>
IHSAATCF or /etc/netview/alert_trap.conf</li>
        <li>The trap-to-alert service configuration file<br>
IHSATCFG or /etc/netview/trap_alert_trap.conf</li>
        <li>The message adapter configuration file<br>
IHSAMCFG or /etc/netview/message_adpt.conf</li>
        <li>The confirmed message adapter configuration file<br>
IHSANCFG or /etc/netview/confirm_message_adpt.conf</li>
        <li>v The event receiver configuration file<br>
IHSAECFG or /etc/netview/event_rcv.conf</li>
    </ul>
    <p>The global initialization file is used to change configurable settings that are
required by all the services. Each of the other configuration files are used to change
configurable settings that are specific to the services. The statements within these
files must all be contained on one line. Each of these files can have comments.
Comment statements begin with the number sign (#).<br>
If the E/AS is started from the IHSAEVNT startup procedure, by default the
8–character PDS name specified is used to locate the file. The file must be in a data
set specified by the IHSSMP3 data set definition statement from the IHSAEVNT
startup procedure. If the E/AS is started from the UNIX System Services command
shell, by default the HFS name specified is used to locate the file.<br>
Every statement in a configuration file can be a comment. If all configuration file
statements are comments, the configuration file will not change any of the
configurable settings. Each of the four configuration files must exist for the E/AS
to properly initialize, even if the file contains nothing but comments. The E/AS
will not initialize if it cannot locate a configuration file.<br>
For more information about the configuration file statements, see the <i>IBM Tivoli
        NetView for z/OS Administration Reference.</i> </p>
    <h2><b>Event/Automation Service Output</b></h2>
    <p>All Event/Automation Service (E/AS) output can be sent to one or both of two
destinations: the generalized trace facility (GTF) and the E/AS output logs. By
default, data is sent to the E/AS output logs. The destination of E/AS output can
be changed using the OUTPUT command or the OUTPUT statement in the global initialization file. Refer to the IBM Tivoli NetView for z/OS Command Reference
        Volume 1 (A-N) and IBM Tivoli NetView for z/OS<i> Administration Reference</i> for more
information.<br>
There is an output log associated with each of the three services, and an output log
associated with the entire E/AS address space. If output log wrapping is disabled,
these output logs are physically represented by one system file. If output log
wrapping is enabled, these output logs are physically represented by two systemfiles — a primary file and a secondary file.<br>
When wrapping is disabled, all output log data is written to the primary file.<br>
When wrapping is enabled, the wrap size is used to limit the total amount of bytes
that can be written to either the primary or the secondary file. When this wrap size
is exceeded, the current file being used for output log output (either the primary or
secondary file) is closed, and the file that was not previously in use (either the
primary or the secondary) is opened for further logging. Whenever an output log
is opened, all data that was previously in the log is destroyed. Therefore, the
maximum amount of output log data available is 2 times the wrap size (both the
primary and secondary files are full), and the minimum amount of output log data
available is the wrap size (a switch has just occurred to either the primary or
secondary file, destroying all data previously in that file).<br>
For more information about setting output log wrapping, refer to the OUTSIZE
parameter in “Customizing the Event/Automation Startup Parameters” on page
115.
</p>
    <h2><b>Event/Automation Service Output Log Names</b></h2>
    <p>When the E/AS is started using the IHSAEVNT startup procedure, the names of
the output logs are defined by the following data set definition statements within
the IHSAEVNT procedure:</p>
    <ul>
        <li>v IHSA (primary file) and IHSAS (secondary file): defines the output log files for
the alert adapter service.</li>
        <li>v IHSB (primary file) and IHSBS (secondary file): defines the output log files for
the confirmed alert adapter service.</li>
        <li>v IHSC (primary file) and IHSCS (secondary file): defines the output log files for
the E/AS address space.</li>
        <li>v IHSE (primary file) and IHSES (secondary file): defines the output log files for
the event receiver service</li>
        <li>v IHSL (primary file) and IHSLS (secondary file): defines the output log files for
an alert-to-trap service.</li>
        <li>IHSM (primary file) and IHSMS (secondary file): defines the output log files for
the message adapter service.</li>
        <li>v IHSN (primary file) and IHSNS (secondary file): defines the output log files for
the confirmed message adapter service.</li>
        <li>v IHST (primary file) and IHSTS (secondary file): defines the output log files for a
            trap-to-alert service.</li></ul>
        <p>If output log wrapping is disabled, the data set definition for the secondary file
does not need to be present in the IHSAEVNT startup procedure, but it is a good
practice to leave it in. The data set definition for the primary file must always be
present.</p>
    <p>By default, the output log files are set to the IHSAEVNT jobs SYSOUT data set. If
SYSOUT data sets are used for the output log files, output log wrapping is
disabled. If you want to enable output log wrapping, you must change these data
set definitions to reference an MVS sequential data set or HFS file.<br>
        <b>Note</b>: There is no restriction placed on the type of file that you specify in the data
set definition statements in the IHSAEVNT startup procedure. However, it is
recommended that you do not define a PDS member as an output log file due to
synchronization problems that may occur when trying to write data to the PDS
member. You also should use a different file for each data set definition statement.<br>
Unless you have been instructed to run with tracing enabled by a Tivoli service
representative, it is recommended that you use the default SYSOUT data sets that
are specified in the sample IHSAEVNT startup procedure and do not enable
output log wrapping.<br>
When the E/AS is started using IHSAC000 in the UNIX System Services command
shell, the names of the output log files are defined as follows:</p>
    <ul>
        <li>v The files must be HFS files. By default, the path of the files is /tmp. This path
can be changed using the -E startup option. Refer to this option on page “-E
path” on page 117.</li>
        <li>controlp.log (primary file) and controls.log (secondary file) are the names of the
output log files for the E/AS address space. These names cannot be changed.</li>
        <li>alertp.log (primary file) and alerts.log (secondary file) are the names of the
output log files for the alert adapter service. These names cannot be changed.</li>
        <li>v calertp.err (primary file) and calerts.err (secondary file) are the names of the
output log files for the confirmed alert adapter service. These names cannot be
changed.</li>
        <li>alrttrpp.log (primary file) and alrttrps.log (secondary file) are output error log
files for the alert-to-trap adapter service.</li>
        <li>trapalrtp.log (primary file) and trapalrts.log (secondary file) are output error log
files for the trap-to-alert service.</li>
        <li>messagep.log (primary file) and messages.log (secondary file) are the names of
the output log files for the message adapter service. These names cannot be
changed.</li>
        <li>cmessagep.err (primary file) and cmessages.err (secondary file) are the names of
the output log files for the confirmed message adapter service. These names
cannot be changed.</li>
        <li>eventrcvp.log (primary file) and eventrcvs.log (secondary file) are the names of
the output log files for the event receiver service. These names cannot be
changed.</li>
    </ul>
    <p>The E/AS creates these output log files if they do not exist.
        <br>
        <b>Note:</b> Unless you have been instructed to run with tracing enabled by a Tivoli
service representative, it is recommended that you do not enable output log
wrapping.</p>
    <h2><b>Types of Event/Automation Service Output Data</b></h2>
    <p>The E/AS generates two types of output data: trace data and error data.<br>
Trace data is only generated if tracing is enabled. By default, tracing is disabled. To
change trace settings, see the <i>IBM Tivoli NetView for z/OS Command Reference Volume 2 (O-Z) for information about the TRACE command, and the IBM Tivoli NetView for
        z/OS</i> Administration Reference for information about the global initialization file
TRACE statement.<br>
In general, tracing should only be used if you are requested to do so by a Tivoli
service representative.<br>
Error data is composed of MVS system console messages and output log only
messages. In general, any error condition detected by the E/AS results in an MVS
console message. This console message is also written to E/AS output. To aid in
problem determination, additional messages may also be written to E/AS output.
These output log only messages that were not issued to the MVS system console
may give more detail concerning the problem.<br>
The combination of system console and output log only messages should allow
you to resolve most E/AS problems without the aid of a Tivoli service
representative.<br>
Not all MVS console messages describe error conditions. There are a number of
informational messages that are also issued by the E/AS and sent to E/AS output
logs.
</p>
    <h2><b>Format of Event/Automation Service Output Data</b></h2>
    <p>When an output log file is initially opened, the first entry in the output log file is
composed of the name of the output file followed by a date/time string in the
format:<br>
day month date time year<br>
The following example shows the header for the message adapter service primary
output log file, assuming that the E/AS was started from the IHSAEVNT startup
procedure:<br>
IHSM Fri Feb 20 10:45:55 2011<br>
All other E/AS output data is composed of a header followed by the specific data.
The header is composed of:</p>
    <ul>
        <li>v A date/time string in the format:<br>
day month date time year</li>
        <li>The module name of the module where the message was issued</li>
        <li>The line number within the module where the message was issued</li>
        <li>The type of message, which can be one of the following:</li>
        <li>v LOW - Specifies this message is issued if the LOW or higher level of tracing has
been enabled.</li>
        <li>v NORMAL - Specifies this message is issued if the NORMAL or higher level of
tracing has been enabled.</li>
        <li>v VERBOSE - Specifies this message is issued if the VERBOSE level of tracing has
been enabled.</li>
        <li>v CONSMSG - Specifies this is an MVS console message.</li>
        <li>v LOGONLY - Species this is a message that accompanies an MVS console
message, but is issued only to E/AS output.</li>
        <li>v IP - Specifies this message is issued if IP tracing has been enabled.</li>
    </ul>
    <p>An example of an E/AS output entry follows:</p>
    <center><img src="Screenshot%20(46).png"></center>
    <h2><b>Customizing Alert and Message Routing from the NetView
program</b></h2>
    <p>When the NetView program is installed, the routing of alert and message data to
the Event/Automation Service is by default disabled. NetView automation table
statements and hardware monitor filter commands are used to enable the routing
of alert and message data to the Event/Automation Service. See the IBM Tivoli
NetView for z/OS Automation Guide for complete information about enabling and
customizing the routing of alerts and messages from the NetView program to the
E/AS.</p>
    <h2><b>Running More Than One Event/Automation Service</b></h2>
    <p>Multiple E/AS address spaces can be active at the same time. In most cases, you
only need one E/AS; however, you might need more than one for any of the
following reasons. You want:</p>
    <ul>
        <li>v A subset of alerts or messages to be translated and sent to a different event
server.</li>
        <li>Alerts or messages to be translated and sent to more than one event server</li>
        <li>A subset of EIF events to be translated and sent to a different NetView alert
receiver.</li>
        <li>EIF events to be translated and sent to more than one NetView alert receiver.</li>
    </ul>
    <p>If you run more than one E/AS, the E/AS PPI mailbox name must be unique for
each. All other configurable settings can be shared between the E/AS invocations.
However, you should consider changing the following configurable settings
between each E/AS invocation:</p>
    <ul>
        <li>v If you use more than one event receiver service, only one should register with
the PortMapper. Others should specify a port number and disable the use of
PortMapper. If more than one event receiver attempts to use the PortMapper, only the last event receiver to access PortMapper is actually registered; all other
registrations for the other event receivers are lost. A warning message is written
to the MVS system console when the event receiver PortMapper registration is
overwritten.</li>
        <li>v The E/AS output log files should be unique for each E/AS invocation.
Otherwise, data from one E/AS are interleaved in the same output log file as
data from another E/AS. If you are using the IHSAEVNT startup procedure to
execute the E/AS, and the output log files are to SYSOUT data sets, then these
data sets are automatically unique for each E/AS invocation.</li>
    </ul>
    <div class="sline">
    </div>
    <h2><b>Advanced Customization - Translating Data</b></h2>
    <p>In addition to the configuration files that the E/AS uses to define operational
characteristics, each E/AS service uses a translation file that contains a set of rules
that tell the service how to translate the incoming data into an EIF event or an
SNMP trap. Each translation file is a text-readable file that can be customized.<br>
The translation files used by the services of the E/AS have two different formats.
The alert adapter, confirmed alert adapter, alert-to-trap, trap-to-alert and event
receiver services use a class definition statement (CDS) translation file. The
message adapter service and confirmed message adapter service uses a message
format translation file.<br>
To customize these translation files, you should have an understanding of the
format of EIF events, SNMP traps, or both.<br>
For additional information about SNMP traps, see the appropriate z/OS
documentation for SNMP agent.<br>
</p>
    <h2><b>Class Definition Statement Files</b></h2>
    <p>The class definition statement (CDS) file defines how to construct EIF events fromthe information that is sent by a data source. For the alert adapter service,
confirmed alert adapter service, and the alert-to-trap service, the data source is the
NetView program. For the event receiver service, the data source is an event
server. For the trap-to-alert service, the data source is an SNMP trap manager. The
statements in this file are referred to as class definition statements. Class definition
statements are rules that enable the service to map the incoming data that it
receives to a console event.<br>
        <b>Note:</b> The event receiver service, alert-to-trap service, and trap-to-alert service
further processes the EIF event that is produced using these class definition
statements to turn it into an alert or SNMP trap. See “Event Receiver Post-CDS
Processing” on page 141 for more information about creating alerts from event
servers. See “Alert-to-Trap Post-CDS Processing” on page 165 for more information
about creating traps from alerts. See “Trap-to-Alert Post-CDS Processing” on page
158 for more information about creating alerts from SNMP traps.<br>
A CDS file is composed of one or more CDS's. Each CDS can include a SELECT, FETCH and a MAP segment that specifies the rules for mapping data into an EIF
event. These rules allow for selecting an event class based on the incoming data,
fetching additional data for creating the console event, and mapping the
information collected from the incoming event into event attributes for the
outgoing EIF event.<br>
A CDS has this general format:<br>
    <img class="pic" src="Screenshot%20(47).png">
<p>The CDS file also supports comment lines beginning with the comment sign (#).
The keywords in a CDS provide the following kinds of information:</p>
    <p><b>CLASS</b></p>
    <p class="pad">The defines the class name that will be used on the outgoing
console event if the incoming data matches this CDS.</p>
        <p><b>SELECT</b></p>
    <p class="pad">CT
Consists of one or more <select_statement> entries that incoming data must
satisfy to match, or select, this CDS. Select statements are evaluated in the
order that they appear in the SELECT segment. If all of the
<select_statements> of a particular CDS are satisfied, then the incoming data
matches the corresponding CDS. Otherwise, the adapter tries to match the
incoming data with the next CDS. If the incoming data cannot be matched
with any CDS, it is discarded.</p>
        <p><b>FETCH</b></p>
        <p class="pad">Consists of zero or more <fetch_statement> entries that are used to retrieve
additional pieces of data from the incoming data in order to build the
event attributes in the map segment. The FETCH segment is used to
retrieve data not retrieved by the SELECT segment, or to change the data
that was retrieved by the SELECT segment.</p>
            <p><b>MAP</b></p>
        <p class="pad">Consists of zero or more <map_statement> entries that specify how to build
the event attributes of the EIF event instance using the service's default
data, user-defined constant data and pieces of data retrieved in the
SELECT and FETCH segments.</p>
        <p>For the alert adapter service, each class of event defined in the .<b>baroc</b> file of the
service on an event server must match one or more CDS in the CDS file. The CDSs
specify how to map incoming data to the class and event attributes of the outgoing
EIF event instance. If you change or add classes or event attributes in the CDS file,
you must make a corresponding change to the .baroc file on the event server. For the event receiver service, the outgoing EIF event is never sent to an event<br>
server; it is a pseudo-event that is processed further to create an alert. Therefore,
there is no corresponding .baroc file on an event server for any EIF events created
from the event receiver's CDS file.<br>
Each CDS is evaluated in the order it appears in the CDS file. An incoming event
is mapped to the class specified by the first CDS whose SELECT segment is
evaluated successfully. When more than one CDS is provided for a given class of
event, the CDS with the most restrictive SELECT segment should appear first in
the CDS file.<br>
If the <class_name> is equal to *DISCARD*, any incoming data matching the
SELECT segment should be discarded. Note that data will also be discarded if it
does not match any CDS. However, if a given type of incoming data must always
be discarded, it is more efficient to define a *DISCARD* statement and put it at
the beginning of the CDS file rather than letting the adapter evaluate all CDS's
before finally discarding the event.
</p>
<h2><b>Encoding Incoming Event Data</b></h2>
        <p>Incoming event data is encoded by the service into name/value pairs. Name/value
pairs are also referred to as attributes. For any incoming event, all of the attributes
are placed in a list that is then used in the SELECT, FETCH and MAP segments.
The service selects which, if not all, of the incoming data to encode into
name/value pairs, see the specific service encoding discussion later in this section.<br>
The name part of the attribute is a text string. There are two types of names -
            <i>generic</i> and <i>keyword.</i>
        <p><b>Generic</b> names are text strings created by the services. A service may create these
names internally, or it may create them from information provided in the incoming
raw data; in either case, the method used by the service to create attribute names
            will be discussed with the specific service encoding later in this chapter.<br><b> Keywords</b> have the format $keyword. Data that is commonly provided in the
incoming datastream to the service is usually coded into keywords rather than
generic names. The actual keyword name is never derived from the incoming data,
but rather is defined by the service.<br>
The main difference between keywords and generic names is how the names are
used in processing the CDS file. Keywords provide faster data lookup during CDS
file processing. Otherwise, keywords and generic names are nothing more than
data tags, with keywords prefaced with $.<br> 
The value part of the attribute is also a text string. Again, the service will assign
this text string based on data in the raw event.</p>
</p>
        <h2><b>Alert Adapter Service, Confirmed Alert Adapter Service, and
Alert-to-Trap Service Data Encoding</b></h2>
    <p>The alert adapter, confirmed alert adapter, and alert-to-trap service uses keyword
attributes exclusively for their data encoding. The following table lists each of the
keyword attribute names used and how the value field is assigned from the
incoming alert data.</p>
    <table>
        <tr>
            <th>Attribute name</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>$ALERT_CDPT</td>
            <td>A 2-byte hexadecimal value taken from the
alert description code field of the generic
alert data subvector, or the resolution
description code field of the resolution data
subvector</td>
        </tr>
        <tr>
            <td>$ORIGIN</td>
            <td>A character string with the name/type
hierarchy pairs from the Hierarchy Name
List or Hierarchy/Resource List subvectors.
The string contains the hierarchy in the
form:
resnam1/typ1,resnam2/typ2,resnam3/typ3,
resnam4/typ4,resnam5/typ5
Only the number of pairs in the actual
subvector are used.</td>
        </tr>
        <tr>
            <td>$SUB_ORIGIN</td>
            <td>A character string with the last pair in the
name/type hierarchy pair list from the
Hierarchy Name List or Hierarchy/Resource List subvectors. The string is in the form:
resnamx/typx where x is the number of the last pair in the
list.</td>
        </tr>
        <tr>
            <td>$HOSTNAME</td>
            <td>The netid.nau node name of the SNA node
where the alert originated. This could be a
NetView/390 node, an AS/400 node, etc.</td>
        </tr>
        <tr>
            <td>$ADAPTER_HOST</td>
            <td>The IP name of the host where the NetView
alert adapter or confirmed alert adapter
resides.</td>
        </tr>
        <tr>
            <td>$DATE</td>
            <td>The date when the alert was received by the
NetView alert adapter or confirmed alert
adapter. In format: MMM HH:MM:SS, e.g. OCT 10
12:08:30.</td>
        </tr>
        <tr>
            <td>$SEVERITY</td>
            <td>FATAL, CRITICAL, etc. The alert type field
from the Generic Alert Data subvector, or
the event type, is used to determine the
severity. Refer to Table 16 on page 127. </td>
        </tr>
        <tr>
            <td>$MSG</td>
            <td>The Long Error Description:Long Probable
Cause message that describes the problem.
This message is similar to the ALERT
DESCRIPTION:PROBABLE CAUSE message
displayed on the NPDA ALERTS-DYNAMIC
panel.
</td>
        </tr>
        <tr>
            <td>$ADAPTER_HOST_SNANODE</td>
            <td>The netid.domainid node name of the
NetView system that sent the alert to the
NetView alert adapter or confirmed alert
adapter.</td>
        </tr>
        <tr>
            <td>$EVENT_TYPE</td>
            <td>For example, PERMANENT, or
TEMPORARY. For Generic Alerts, it is
obtained by inspecting the Alert Type byte
of Generic Alert Data subvector. It matches
the EVENT TYPE displayed on the NPDA
EVENT DETAIL panel.</td>
        </tr>
        <tr>
            <td>$ARCH_TYPE</td>
            <td>GENERIC_ALERT, GENERIC_RESOLUTION, or
NONGENERIC_ALERT. NMVT Alert Major
Vectors contain a Generic Alert Data
subvector are GENERIC_ALERTs. NMVT
Resolution Major Vectors are GENERIC_RESOLUTIONs. All other alerts are NONGENERIC_ALERTs.</td>
        </tr>
        <tr>
            <td>$PRODUCT_ID</td>
            <td>The hardware or software product set
identifier (PSID) of the alert or event sender. This can be 4, 5, 7, or 9 characters. Pertains
to all generic alerts and some non-generic
alerts.
</td>
        </tr>
        <tr>
            <td>$ALERT_ID</td>
            <td>An 8-character hexadecimal value assigned
by the sender to designate an individual
alert condition. The value will always be
00000000 for resolution alerts. Pertains only
to generic alerts (including resolutions).</td>
        </tr>
        <tr>
            <td>$BLOCK_ID</td>
            <td>The code used to identify the IBM hardware or software associated with the alert. See the
NetView Resource Alerts Reference manual.
Pertains only to non-generic alerts.</td>
        </tr>
        <tr>
            <td>$ACTION_CODE</td>
            <td>A code that provides an index to predefined
screens. Pertains only to non-generic alerts.
For non-generic alerts, the combination of
the block id and action code uniquely
identify the sending product.</td>
        </tr>
        <tr>
            <td>$SELF_DEF_MSG</td>
            <td>Text extracted from Self-defining Text
Message Sv31.</td>
        </tr>
        <tr>
            <td>$EVENT_CORREL</td>
            <td>Correlators extracted from MSU Correlation
Sv47. These correlators correlate alerts to
other alerts. That is, you may have two or more alerts that pertain to the same
underlying problem and such alerts are
correlated by Sv47. The tecad_snaevent.rls
file on the event manager server contains
rules that discard alerts that have already
been reported.</td>
        </tr>
        <tr>
            <td>$INCIDENT_CORREL</td>
            <td>Correlators extracted from Incident
Identification subvectors. These correlators correlate alerts to resolutions. The
tecad_snaevent.rls file on the event manager
server contains rules that CLOSE all correlated alerts when a resolution is
received</td>
        </tr>
        <tr>
            <td>$ADAPTER_CORREL</td>
            <td>A correlator that has meaning only to the
alert adapter</td>
        </tr>
        <tr>
            <td>$DETAILED_DATA</td>
            <td>Always assigned the string "[N/A]".</td>
        </tr>
    </table>
    <p>Non-keyword attributes can also be assigned by users in the NetView address
space. Refer to IBM Tivoli NetView for z/OS Automation Guide for more information
about how to customize alerts forwarded from the NetView program. Using this
method, any attribute name/value pair can be created and used by the CDS file
process. The alert adapter and trap-to-alert service do not use generic attributes
other than when they are assigned within the NetView program.<br>
The value for the severity event attribute is determined by mapping an alert type
(or event type) to a severity. The following table shows this mapping. The
        hexadecimal byte is the alert type field from the generic alert data subvector.<br><i> Table 16. Alert Types and Severities</i>
</p>
    <table padding-right: 200px;>
        <tr>
            <th>Alert Type</th>
            <th>Sebverity</th>
        </tr>
        <tr>
            <td>0x01, PERMANENT</td>
            <td>CRITICAL</td>
        </tr>
        <tr>
            <td>0x02, TEMPORARY</td>
            <td>HARMLESS</td>
        </tr>
        <tr>
            <td>0x03, PERFORMANCE</td>
            <td>WARNING</td>
        </tr>
        <tr>
            <td>0x04, INTERVENTION REQ'D</td>
            <td>CRITICAL</td>
        </tr>
        <tr>
            <td>0xNN, CUSTOMER APPLICATION</td>
            <td>MINOR</td>
        </tr>
        <tr>
            <td>0xNN, END USER GENERATED</td>
            <td>MINOR</td>
        </tr>
        <tr>
            <td>0xNN, SUMMARY</td>
            <td>HARMLESS</td>
        </tr>
        <tr>
            <td>0xNN, INTENSIVE MODE REC</td>
            <td>HARMLESS</td>
        </tr>
        <tr>
            <td>0x09, AVAILABILITY</td>
            <td>CRITICAL</td>
        </tr>
        <tr>
            <td>0x0A, NOTIFICATION</td>
            <td>WARNING</td>
        </tr>
        <tr>
            <td>0x0B, ENVIRONMENT</td>
            <td>CRITICAL</td>
        </tr>
        <tr>
            <td>0x0C, INSTALLATION</td>
            <td>WARNING</td>
        </tr>
        <tr>
            <td>0x0D, OPERATION/PROCEDURE</td>
            <td>WARNING</td>
        </tr>
        <tr>
            <td>0x0E, SECURITY</td>
            <td>CRITICAL</td>
        </tr>
        <tr>
            <td>0x0F, DELAYED RECOVERED</td>
            <td>WARNING</td>
        </tr>
        <tr>
            <td>0x10, PERMANENT AFFECTED</td>
            <td>MINOR</td>
        </tr>
         <tr>
            <td>0x11, IMPENDING PROBLEM</td>
            <td>WARNING</td>
        </tr>
         <tr>
            <td>0x12, UNKNOWN</td>
            <td>UNKNOWN</td>
        </tr>
         <tr>
            <td>0xNN, HELD</td>
            <td>MINOR</td>
        </tr>
         <tr>
            <td>0x14, BYPASSED</td>
            <td>WARNING</td>
        </tr>
         <tr>
            <td>0x15, REDUNDANCY LOST</td>
            <td>WARNING</td>
        </tr>
         <tr>
            <td>0x16, SITUATION</td>
            <td>WARNING</td>
        </tr>
    </table>
    <h2><b>Alert-to-Trap Service Data Encoding</b></h2>
    <p>The alert-to-trap service constructs enterprise traps (type 6). The CDS file enables
customization of the specific code field in the trap. This is done by supplying a
value for the SPECIFIC keyword in the MAP sections of the CDS file.<br>
The basic approach of the alert-to-trap service is to construct EIF event
keyword/value pairs from the alert and then map the keyword/value pairs (other
than SPECIFIC) into SNMP OCTET strings to be included as variable bind data in
the resulting trap. Both the keyword and the value are included in the resulting
OCTET string.<br>
The alert-to-trap service has access to the alert-adapters keyword attributes, and
these can be used in SELECT, MAP and FETCH statements. However, not all alert
adapter attributes are applicable to SNMP traps.<br>
The CLASS names in class definition statements are not used in the traps built by
the alert-to-trap servicer. However, the CLASS name is still required to satisfy CDS
syntax rules, and it is useful when you document the trap you are constructing</p>
    <h2><b>Trap-to-Alert Service Data Encoding</b></h2>
    <p>The trap-to-alert service receives an SNMP trap as its incoming data. This data is
encoded into both keyword attributes and generic attributes.<br>
        The following table lists the keyword attributes created by the trap-to-alert service.</p>
        <table>
            <tr>
                <th>Attribute Name</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>$ORIGIN_ADDR</td>
                <td>The value is a string containing the IP
address from which the trap came. Note that
when the sample datagram forwarding
daemon is used, the value is the IP address of the host in which the daemon is running.</td>
            </tr>
             <tr>
                <td>$ORIGIN_PORT</td>
                <td>The value is a string containing the number
of the port (in decimal) at the origin address
from which the trap came. Note that when
the sample datagram forwarding daemon is
used, the value is the number of the port
over which the daemon forwarded the trap</td>
            </tr>
             <tr>
                <td>$SNMP_VERSION</td>
                <td>The value is a string containing the number
(in decimal) indicating which SNMP version
was implemented at the agent that sent the
trap. This determines how the trap was
formatted. The value for SNMPv1 is "0".
</td>
            </tr>
             
    </table>
    <p>The following table lists the generic attributes created by the trap-to-alert service
from the SNMP trap data that is not a variable binding. All data is converted to a
character string before assigning it to the generic attribute name.</p>
    <table>
        <tr>
            <th>Attribute Name</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>community</td>
            <td>The value of the SNMP trap community
field.</td>
        </tr>
         <tr>
            <td>enterpriseOID</td>
            <td>The value of the SNMP trap enterpriseOID
field.</td>
        </tr>
         <tr>
            <td>agent_address</td>
            <td>The value of the SNMP trap agent address
field</td>
        </tr>
         <tr>
            <td>generic_trap</td>
            <td>The value of the SNMP trap generic trap
field.</td>
        </tr>
        <tr>
            <td>specific_trap</td>
            <td>The value of the SNMP trap-specific trap
field.</td>
        </tr>
        <tr>
            <td>timestamp</td>
            <td>The value of the SNMP trap timestamp field</td>
        </tr>
    </table>
    <p>The variable binding data is created directly from the variable binding data. The
variable binding name becomes the name of the generic attribute, and the variable
binding data is converted to a character string if it is not already a character string
and assigned to the generic attribute. When more than one variable binding within
an SNMP trap contains the same name, the name and index are appended to the
name to create the generic attribute name. For example, if the variable binding
name<br>
1.3.6.1.4.1.2.2.1.3.1.0<br>
occurred 3 times within the same SNMP trap, the generic attribute names that are
created as a result would be as follows:<br>
1.3.6.1.4.1.2.2.1.3.1.0<br>
1.3.6.1.4.1.2.2.1.3.1.0<1><br>
1.3.6.1.4.1.2.2.1.3.1.0<2></p>
        <h2><b>Event Receiver Service Data Encoding</b></h2>
        <p>The event receiver service receives an EIF event as incoming data. This data is
encoded into both keyword attributes and generic attributes. This encoding is very
straightforward since the data is already in the name/value form of an attribute.
Every event attribute name in the incoming console event becomes the name of a
generic attribute in the attribute list, and the corresponding event attribute value
becomes the value of the attribute. The className of the event is encoded as the
Chapter 8. Customizing the Event/Automation Service 129
value of the $CLASSNAME keyword attribute. As such, the event receiver creates
one keyword attribute, $CLASSNAME, and as many generic attributes as there are
event attribute/value pairs in the incoming console event.</p>
        <h2><b>SELECT Segment of a Class Definition Statement</b></h2>
        <p>The SELECT segment of a CDS is composed of one or more <select_statement>
entries. Each <select_statement> entry has the following format:<br>
<n>: ATTR(<a_op>, <a_op_value>),<br>
VALUE(<v_op>, <v_op_value>);<br>
A <select_statement> is satisfied if an attribute is found in the list of attributes
    provided by the service that fulfills the conditions specified by the<b> ATTR </b>and
    <b>VALUE</b> expressions of the <select_statement>. An attribute must be found for each
<select_statement> for the SELECT segment to be satisfied. If a SELECT segment is
not satisfied, the entire CDS is ignored and processing continues with the next
CDS in the CDS file.</p>
    <p><b>ATTR</b></p>
    <p class="pad">Specifies the name of an attribute, in <a_op_value> and a modifying
        condition on the attribute name in <a_op>. The<b> ATTR</b> expression is
mandatory in the SELECT statement. The list of attributes created by the
service from the incoming data are searched until an attribute is found that
        has a name field which matches the condition expressed by the <b>ATTR</b>
expression</p>
        <p><a_op></p>
            <p class="pad">>
Modifies the ATTR name and can have one of the following values:<br> = Specifies that the attribute name in <a_op_value> must match the
name of an attribute in the attribute list.</p>
                <p><b>PREFIX</b></p>
        <p class="pad">Specifies that the attribute name in <a_op_value> must be a prefix
of the name of an attribute in the attribute list.</p>
                            <p><b>SUFFIX</b></p>
        <p class="pad">Specifies that the attribute name in <a_op_value> must be a suffix
of the name of an attribute in the attribute list</p>
<p><a_op_value></p>
    <p class="pad">Specifies the name of an attribute. The attribute list is searched sequentially
and the ATTR <a_op> expression is applied to each attribute name field
until a matching attribute is found.<br>
By default, <a_op_value> is a string. However, <a_op_value> can also be a
variable. Variables are described in the list that follows.<br>
When specified as a string, <a_op_value> must be enclosed in double
quotes (") if the string contains a blank character or if it is all digits (0
through 9). The following examples show possible <a_op_value> strings:<br>
hello<br>
$ORIGIN<br>
"hello, world"<br>
"12"
</p>
        <p><b>Keyword</b></p>
        <p class="pad">A keyword provided by the event adapter, for example, $ORIGIN.</p>
        <p><b>Name</b></p>
        <p class="pad">Name variables are assigned the value of the name field of an
attribute that has satisfied a previous <select_statement>ATTR
expression. A name variable is specified as $Nn, where n is the
number of the <select_statement> that the desired attribute satisfied
(for example, $N2).</p>
            <p><b>Value</b></p>
            <p class="pad">Value variables are assigned the value of the value field of an
attribute that has satisfied a previous <select_statement> VALUE
expression. A value variable is specified as $Vn, where n is the
number of the <select_statement> that the desired attribute satisfied
(for example, $V5).</p>
                <p>The following example of an ATTR expression looks for a generic name that is
equal to user1. If the service has provided an attribute named user1, the ATTR
expression will be satisfied.<br>
ATTR(=,"user1")<br>
The following example of an ATTR expression looks for a keyword that is equal to
$ORIGIN. If the service has provided an attribute named $ORIGIN, the ATTR
expression will be satisfied.<br>
ATTR(=,$ORIGIN)</p>
                <p><b>VALUE</b></p>
                <p class="pad">This expression is optional. For the attribute in the attribute list that
matches the associated ATTR expression, the value of the attribute is
subjected to a match based on the information in the VALUE expression.</p>
                <p><v_op></p>
                    <p class="pad">>
Modifies the VALUE expression and can have one of the following values:<br> = Specifies that the VALUE expression in <v_op_value> must match<br>
the value of an attribute in the attribute list.</p>
                        <p><b>PREFIX</b></p>
                <p class="pad">Specifies that the VALUE expression in <v_op_value> must be a
prefix of the value of an attribute in the attribute list.</p>
                                        <p><b>SUFFIX</b></p>
                <p class="pad">Specifies that the VALUE expression in <v_op_value> must be a
suffix of the value of an attribute in the attribute list.<br>
!= Specifies that the VALUE expression in <v_op_value> must not be
equal to the value of an attribute in the attribute list.</p>
                    <p><v_op_value></p>
                        <p class="pad">p_value>
Specifies the value of an attribute. By default, <v_op_value> is a string.
However, <v_op_value> can also be a variable.<br>
When specified as a string, <v_op_value> must be enclosed in double
quotation marks (") if the string contains a blank character or if it is all
digits (0 through 9). The following examples show possible <v_op_value>
strings:<br>hello<br>
$ORIGIN<br>
"hello, world"<br>
"12"<br>
When specified as a variable, <v_op_value> can contain any of these types
of variables:</p>
<p><b>Keyword</b></p>
                            <p class="pad">The keyword is assigned a constant value (either a string or a
number), and the keyword can be used to reference the value.</p>
                            <p><b>Name</b></p>
                            <p>Name variables are assigned the value of the name field of an
attribute that has satisfied a previous <select_statement> ATTR
expression. A name variable is specified as $Nn, where n is the
number of the <select_statement> that the desired attribute satisfied
(for example, $N2).</p>
                                <p><b>Value</b></p>
                                <p>Value variables are assigned the value of the value field for an
attribute that has satisfied a previous <select_statement> VALUE
expression. A value variable is specified as $Vn, where n is the
number of the <select_statement> that the desired attribute satisfied
(for example, $V5).<br>
The following example of a VALUE expression looks for an attribute with a value
that is prefixed with Serial:<br>
VALUE(PREFIX,"Serial")<br>
A valid match for this VALUE expression is Serial1.</p>
<p><b>SELECT Segment Evaluayion</b></p>  
   <ul><li>For an entire SELECT segment to be matched, an attribute must be matched for
each of the <select_statement> expressions in that SELECT segment. More than
one attribute in the attribute list may satisfy a <select_statement>. The first one
in the attribute list that satisfies the statement is used for further CDS
processing.</li>
       <li>If the SELECT segment is satisfied, the class name of the SELECT segment is
used for the outgoing EIF event. Processing of the event continues with the
FETCH segment, unless the class is *DISCARD*, in which case the event is
discarded. If the incoming data satisfies no SELECT segment of a CDS in the
CDS file, the incoming data is discarded.</li>
       <li>Each time a <select_statement> is evaluated successfully, the two variables $Nn
and $Vn are created. These variables, along with the adapter-provided
keywords, can be used in any subsequent SELECT, FETCH, or MAP segment.</li></ul>  
       <h2><b>FETCH Segment of a Class Definition Statement</b></h2>
       <p>The SELECT segment of a CDS retrieves attribute names and values from the
incoming data, but it does not allow for changes to the selected pieces of
information. In some circumstances, it is necessary to extract a substring out of an
attribute value or to provide user-defined variables. The FETCH segment in a CDS
allows you to do this.<br>
The FETCH segment is composed of one or more <fetch_statement> expressions.
Each <fetch_statement> has the following format:<br>
<n>: <expression></p>
    <p>Where</p>
    <p class="pad">
<n> Is an identification number of the <fetch_statement>. <n> can be any valid
integer. Each <fetch_statement> must have a unique identification number. A <fetch_statement> results in the value of <expression> being assigned to a
new variable, $Fn, where n is the identification number of the
<fetch_statement>.</p>
    <p><expression></p>
        <p class="pad">Is one of the following:</p>
    <ul>
        <li>A string</li>
        <li>v Any output value from the SELECT segment (such as adapter-provided
keywords and SELECT segment variables.</li>
        <li>Any output from a previous <fetch_statement></li>
            <li>A substring with any combination of strings, SELECT segment output,
and <fetch_statement> output.</li>
    </ul>
    <p>An example of a FETCH segment using substrings is:<br>
1: SUBST ($V2, 1, 5);,br>
This statement uses the value of the variable $V2, as assigned from
<select_statement> number 2, and assigns the substring represented by the first 4
characters of $V2 to the variable $F1.<br>
The output of the FETCH segment is the set of fetch variables $Fn.</p>
        <h2><b>MAP Segment of a Class Definition Statement</b></h2>
    <p>The MAP segment of a CDS creates the event attributes and associated values that
are put in the outgoing EIF event.<br>
The MAP segment is composed of one or more <map_statement> expressions. Each
<map_statement> has one of the following formats:<br>
<slot name> = <string>;<br>
<slot name> = <variable>;<br>
<slot name> = PRINTF(<format_string>, <var1>, ..., <varn>);</p>
    <p>&lt slot_name &gt</p>
        <p class="pad">The name of any event attribute. For the alert adapter service, this should
be an event attribute that corresponds to an event attribute in the service's
            <b>.baroc</b> file on an event server. For the event receiver service, this should be
an event attribute that is allowed by the event receivers post-CDS file
processing.</p>
    <p>&lt; string &gt;</p>
    <p class="pad">Any character string.
</p>
    <p>&lt;variable&gt;</p>
    <p class="pad">Any variable passed to the MAP segment from the SELECT or FETCH
segments, such as adapter-defined keywords or segment variables.</p>
    <P><b>PRINTF</b></P>
    <p class="pad">Specifies a format that allows the value of the event attribute to be
formatted using a C-style printf() format string. This format string
currently supports only the %s format specifier.</p>
    <p>Here is an example of a MAP segment:<br>MAP<br>
origin = $V2;<br>
hostname = $HOSTNAME;<br>
msg = PRINTF("The origin is %s", $V2);</p>
    <p>In this example, the<b> origin</b> event attribute would be given the value of the SELECT
        segment variable $V2. The <b>hostname</b>  event attribute would be given the value of
the $HOSTNAME keyword. Assuming the value of the variable $V2 is
NV390SP/SP, the msg event attribute would be given the value "The origin is
NV390SP/SP" (the double quotes are not included in the value).
The output of the map process is a list of event attribute name/value pairs that are
used to generate the outgoing EIF event that is either sent to the event server or
used for post CDS-file processing.</p>
    <h2><b>MAP_DEFAULT Section of the Class Definition Statement Files</b></h2>
    <p>Some event attributes, like source and hostname, will probably have a constant
value for all the EIF events generated by a given service. To avoid repeating
identical map statements in many CDS's, the CDS file supports a MAP_DEFAULT
section. This section defines event attribute name/value pairs for all CDS's in the
CDS file. The event attributes that are defined in this global definition section can
be overridden by specific definitions in a CDS.<br>
Here is an example of a MAP_DEFAULT section:<br>
MAP_DEFAULT<br>
origin = $ORIGIN;<br>
sub_origin = $SUB_ORIGIN;<br>
msg = $MSG;<br>
END</p>
    <p>In some cases, you may want to put CDSs into more than one CDS file and have
them all be used by a service. To enable this, an extension to normal CDS file
processing has been added for the E/AS services. The %INCLUDE statement
allows additional CDS files to be embedded within the current CDS file. The
%INCLUDE keyword cannot be preceded by blank characters, and it must be
followed by a separator of one blank character. Following the separator is the file
name of the CDS file to be opened. This file name is either a 1 to 8 character PDS
member name that is associated with the IHSSMP3 data set definition, or a
complete file name that is preceded by the backslash ('\') character. The maximumnumber of CDS file members that can be opened at the same time is 20; this
represents the maximum number of nested %INCLUDE statements that are valid.<br>
The following example shows the %INCLUDE statement syntax. Assume that the
file named IHSAACD1 contains the single statement:<br>
sub_origin = $SUB_ORIGIN;</p>
    <p>In this example:<br>
MAP_DEFAULT &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Statements from IHSAACDS<br>
source = NV390ALT;<br>
origin = $ORIGIN;<br>
%INCLUDE IHSAACD1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//New file with sub_origin statement<br>
hostname = $HOSTNAME; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Continuation of IHSAACDS<br>
adapter_host = $ADAPTER_HOST;<br>
END</p>
    <h2><b>Message Format Files</b></h2>
    <p>The FMT file defines how the message adapter service and the confirmed message
adapter service construct EIF events from message information that is sent by the
NetView program. The statements in this file are referred to as format specification
statements (FSS). Format specification statements are rules that allow a service to
map the incoming message data that it collects from the NetView program to an
outgoing console event.<br>
The following sections describe the syntax of the message and confirmed message
adapter service format specifications and how format specifications are mapped
into events.</p>
    <h3><b>Encoding Incoming Event Data</b></h3>
    <p>For the message adapter service and the confirmed message adapter service, the
incoming data is a message string. This message text string is matched against
        <b><i>format specifications</i></b> in the FMT file. The primary piece of information, therefore,
is the message string itself.<br>
Like a CDS file, the job of the FMT file is to allow the user to customize the
outgoing console event based on the incoming message data. This method does not
encode the data into attributes; however, there are certain event attribute names
that receive default information from the incoming message data.<br>
The following table lists each of the default event attribute names and their
corresponding default values. If the value for the event attribute is not actually
present in the incoming data, then the default event attribute value will be the null
string. ANY event attribute that is listed in the map rules portion of a format
specification statement has a default value; if it is not provided in the incoming
data, its default value is the null string ("").</p>
    <table>
        <tr>
            <th>Event attribute name</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>origin</td>
            <td>The netid.domainid node name of the
NetView system where the message
originated.</td>
        </tr>
        <tr>
            <td>sub_origin</td>
            <td>The job number associated with the
message. If a job number is not available for
the message, the value defaults to a null
string ("").</td>
        </tr>
        <tr>
            <td>host name</td>
            <td>Same as the origin event attribute</td>
        </tr>
        <tr>
            <td>adapter_host</td>
            <td>The IP name of the host where the
Event/Automation Service is running</td>
        </tr>
        <tr>
            <td>date</td>
            <td>The date and time that the message was sent
from the NetView automation table. In
format: MMM HH:MM:SS, e.g. OCT 10 12:08:30</td>
        </tr>
        <tr>
            <td>msg_id</td>
            <td>The first token of the message. In most
cases, this token is the actual message
identifier.</td>
        </tr>
        <tr>
            <td>severity</td>
            <td>Inferred from the last character of the
msg_id. The translation of this character to a
value for this event attribute is:
A, E, S CRITICAL
T FATAL
anything else WARNING</td>
        </tr>
        <tr>
            <td>msg</td>
            <td>The message text, which includes msg_id as
the first token.</td>
        </tr>
        <tr>
            <td>adapter_host_snanode</td>
            <td>The netid.domainid node name of the
NetView system that sent the message to the
message adapter service or the confirmed
message adapter service.</td>
        </tr>
        <tr>
            <td>multiline_msg</td>
            <td>The second and succeeding message lines
from the message. If the message is
contained in one line, the value of
multiline_msg is N/A.</td>
        </tr>
        <tr>
            <td>jobname</td>
            <td>The jobname associated with the message. If
a jobname is not available for the message,
the value of jobname defaults to a null
string ("").
</td>
        </tr>
    </table>
    <p>Default event attributes and values can also be assigned by users in the NetView
address space. Refer to the IBM Tivoli NetView for z/OS Automation Guide for more
information about customizing messages forwarded from the NetView program.
Using this method, any attribute name/value pair can be created and used by the
FMT file process.</p>
    <h3><b>Format Specifications</b></h3>
    <ul>
        <li>The format header has the keyword<b> FORMAT</b> followed by the class name. This
is optionally followed by the FOLLOWS keyword and a previously defined
            <b>FORMAT</b> class name. If the incoming message matches this FSS, the class name
            following the<b> FORMAT</b> keyword is used on the outgoing EIF event.</li>
        <li>The format content has a format string optionally followed by a list of map
            rules. The format string performs a function similar to the <b>SELECT</b> segment of a
CDS file; that is, it matches the incoming message to a particular FSS. The map
            rules perform a function similar to the <b>MAP</b> segment in the CDS file; that is,
they assign values to event attributes.</li>
        <li>v The END keyword completes the FSS</li>
    </ul>
    <p>The format header, the format string, each map rule, and the END keyword must
begin on a new line.<br>
The FOLLOWS relationship is used to enable a specific FSS to be built from more
generic ones. When format B follows format A, B inherits all of the map rules (but
not the format string) from A. Format B can define any additional map rules, but
any map rules redefined by B are not inherited from A. Format B can override
inherited map rules by redefining them.<br>
Messages that are forwarded by the NetView program typically have a common
format consisting of a message identifier and message-specific text. These message
components can be represented in the format string using a component specifier</p>
    <p>notation that is very similar to the C-style printf() notation. This printf() notation
is similar to the notation used in CDS files.<br>
The following format string describes the entire class of messages that are
produced by the NetView automation table:<br>
%s*<br>
Input messages are tokenized into constants and blanks. A constant is any
consecutive string of non-blank characters. Component specifiers allow the
constants and blanks to be grouped into more complex "tokens" when trying to
match an FSS against a specific message. The current allowable component
specifiers are:<br>
        <b><i>%lengths</i></b> Matches one constant in the input message<br>
        <b><i>%lengths*</i></b> Matches zero or more constants in the input message<br>
        <b><i>%lengths+</i></b> Matches one or more constants in the input message<br>
The optional length is a decimal number of any size that truncates the constant if
the actual length is greater than the specifier length. For the specifiers that can
match multiple constants, each constant in the accumulated string is truncated.
Also, the string itself terminates on a constant that is less than the specifier length.<br>
The format string DSI%s %s* is taken from the default message adapter FMT file
shipped with the E/AS, and is used in the following discussion to demonstrate the
usage of format strings.<br>
As an example of matching a message to the DSI%s %s* format specification,
consider the following NetView message:<br>
DSI002I INVALID COMMAND: ’BADCOMMAND’ The component specifiers and matches are as follows:<br>DSI DSI<br>
%s 002I<br>
%s* INVALID COMMAND:’BADCOMMAND’<br> The DSI002I message has some constant parts and some variable parts. That is,
certain parts of the message (constant parts) will be the same for any DSI002I
message that is generated. The constant parts of the message are:<br>
DSI002I INVALID COMMAND: ’ ’ The variable part of the message is:<br>
BADCOMMAND<br>
Note that the first constant part of the message goes all the way to the first single
quote (') in the message. The second single quote is the beginning of the second
constant part of the message, which also happens to be the last character in the
message. The data inside of the single quotes is all variable.<br>
The following message is an example of another DSI002I message with different
variable parts:<br>
DSI002I INVALID COMMAND: ’WORSE COMMAND’<br>
In this case, the variable part is composed of two words and a space -- WORSE
COMMAND.<br>The format string DSI%s %s* can be specialized for the DSI002I message as
follows:<br>
DSI %s INVALID COMMAND: ’%s*’ <br>Using the previously described DSI002I message, the component specifiers and
matches are as follows:<br>
DSI DSI<br>
%s 002I<br>
INVALID COMMAND: ’INVALID COMMAND: ’<br>
%s* WORSE COMMAND<br>
’ ’ The blank characters that separate the words of a message must also be present in
the format string. A single space character in the format string will match any
number of blank characters in the message.<br>
Suppose the space between the colon (:) and the quote (') is deleted in the
specialized DSI002I format string given previously:
DSI %s INVALID COMMAND:’%s*’<br>
In this example, the format string would no longer match DSI002I messages.
However, in the following example, the NetView message would match the format
specification, since all consecutive blanks from both the input message and the
format specification are boiled down to a single blank character:
DSI %s INVALID COMMAND: ’%s*’<br> Care should be taken when using arbitrary length repeater component specifiers
(%s* and %s+ ). The following format string does not make much sense:
This is not a good format %s* %s*<br>
The first %s* matches everything through the end of the message, and the second
%s* will never match anything. It might appear that this does not matter, but the
importance becomes obvious when map rules are discussed in “Map Rules.”<br>The following format string, however, is meaningful:<br>
This is a good format %s* : %s*<br>
The first %s* matches everything up to the first colon (:), and the second %s*
matches everything through the end of the message.<br>
From the examples here, you can see that you can specialize a generic format to
match a more specific event by either replacing component specifiers with
constants or by restricting the arbitrary length repeater specifiers to a fixed length
by using constants to terminate the specifier.<br>
    </p>
    <h3><b>Map Rules</b></h3>
    <p>The service translates incoming message data into an event class with event
attribute name/value pairs, and sends this information to an event server. As with
the alert adapter service, a .baroc file at the event server must be present to match
the outgoing EIF events created by the message adapter service. This is not
required for the confirmed message adapter service.<br>
The event class is determined by matching an input message to an FSS as
described previously. However, once the class is determined. Values must be
assigned to the event attribute names. These values can come from a variety of places, such as from the message itself, from default event attributes provided by
the service, or from specifications within the FMT file. Map rules define how event
attributes are assigned values.<br>
The map rule portion of the format string consists of zero or more lines that
contain a .baroc file event attribute name followed by a value specifier. The value
specifiers are one of four types:</p>
    <ul>
        <li>v $i , where i indicates the position of a component specifier in a format string.
Each component specifier is numbered from 1 to the maximum number of
component specifiers in the format string. For example, in the specialized format
specification for the DSI002I message given previously, the %s* component
specifier would be referred to in the map rules as $2. The value of a $i value
specifier, also referred to as a variable value specifier, is the portion of the input
message that was consumed by the component specifier. These variables are
very similar to the variables output from the SELECT and FETCH segments in
the CDS file.</li>
        <li>v A constant string. The value of the event attribute is the specified string. If the
string is a single constant, it can be specified without surrounding double quotes
("). Otherwise, double quotes must be used.</li>
        <li>A <b>PRINTF</b> statement. This mechanism allows you to compose more complex
event attributes from other event attributes. The PRINTF statement consists of
            the keyword <b>PRINTF</b> followed by a C-style printf() format string and a list of
event attribute names. The printf() format string currently only supports the %s
conversion specifier. The values of the event attributes that are used in the
            <b>PRINTF</b> statement must also have been derived from either the $i value
specification or a constant string value specification. They cannot be derived
            from another<b> PRINTF</b> value specification. The value of the argument event
attributes will be used to compose a new constant string according to the
printf() format string. This constant string becomes the value of the event
            attribute. This value specifier is very similar to the<b> PRINTF</b> MAP segment
format in the CDS file.</li>
        <li><b>DEFAULT.</b> This keyword indicates that the adapter should use its internal logic
to derive the value of the indicated event attribute. For example, the incoming
message data contains the hostname (netid.nau) where the message originated. If
the hostname event attribute is therefore set to the value DEFAULT, netid.nau
will be the value of the hostname event attribute. This is similar to the use of
keywords in the alert adapter service.<br>
If the incoming message does not provide a specific value for a slot, the
DEFAULT value is the null string (""). The DEFAULT value for non-specified slot
names can be overridden. An additional value specifier, delimited with a colon
(:), may follow the DEFAULT value specifier. This value specifier will be used to
provide the DEFAULT value of the slot only if a slot value is not provided in the
incoming message.<br>
Only constant string and $i variable specifiers can be used to provide DEFAULT
overrides.<br>
For example, the following assigns the slot numericslot with the DEFAULT value
from the incoming message:<br>
numericslot DEFAULT : 0<br>
If the incoming message does not contain a value for numericslot, a value of 0 is
assigned rather than a null string.<br>
Note that because DEFAULT is a keyword, a constant map whose value is the
string DEFAULT must be specified in double quotes ("").
</li>
    </ul>
    <p>You should specify only one map rule for each .baroc file event attribute in any
one format specification. The map rule can be inherited from a more generic
format specification (using the FOLLOWS keyword), or it can be explicitly defined
on the format specification that directly matches the input message. Since the
service does not have access to the .baroc file, which resides on the event server, care must be taken to make sure that the format specifications agree with the
corresponding .baroc file definitions. If an event attribute name is misspelled in a
map rule, for example, the service will not report any error and will send the event
to the event server as usual. However, the event will be meaningless to the event
server. <br>There can be attributes in the incoming message that do not directly correspond to
        any <b>.baroc</b> file event attributes. However, the service might need to use these
values to compose PRINTF style constant strings. This data needs to be assigned
        to temporary event attributes, which can then be used in the<b> PRINTF</b> value
specification but does not allow the event attribute to be sent over to the event
server as an independent event attribute name/event attribute value pair. Temporary event attributes are designated with a minus sign (-) immediately
preceding the event attribute name in the map rule. These temporary event
attributes are not .baroc file event attributes. Do not use the minus sign (-) when
referring to the temporary event attribute in the PRINTF specification</p>
    <h2><b>%INCLUDE Statements</b></h2>
    <p>%INCLUDE Statements
        The %<b>INCLUDE</b> statement allows additional FMT files to be imbedded within the
current FMT file. The %INCLUDE keyword cannot be preceded by blank
characters, and it must be followed by a separator of one blank character. Following the separator is the file name of the FMT file to be opened. This file
name is either a 1 to 8 character PDS member name that is associated with the
IHSSMP3 data set definition, or a complete file name that is preceded by the
backslash ('\') character. The maximum number of FMT file members that can be
opened at the same time is 20; this represents the maximum number of nested
%INCLUDE statements that are allowed.<br>
        <b>Format File Example:</b> The following sample is used to demonstrate the concepts
discussed previously; this example was taken (and modified somewhat) from the
message adapter services default message format file (IHSAMFMT):<br>
FORMAT NV390MSG_Event<br>
%s*<br>
source NV390MSG<br>
origin DEFAULT<br>
desctext "This string will be overridden"<br>
END<br>
FORMAT NV390MSG_NetView_NCCF FOLLOWS NV390MSG_Event<br>
DSI%s %s*<br>
sub_source "NetView NCCF"<br>
msgnumber $1<br>
temp1 $2<br>
desctext PRINTF("Got a DSI message: %s", temp1)<br>
END<br>
%INCLUDE MOREFMTS<br>Using this format file, assume that the following message is received by the
service:<br>
DSI002I INVALID COMMAND: ’A BAD COMMAND’ This message matches the NV390MSG_NetView_NCCF format specification defined
previously IF the additional format statements include in MOREFMTS do not specify</p>
    <p>another format specification that this message can match on. Remember, matches
on the FSS in the FMT file begin with the last FSS in the file and progress toward
the first FSS until a match occurs.<br>
With this match, the source event attribute will be assigned the string value
NV390MSG. The origin event attribute will be assigned whatever default the event
adapter associates with this event attribute. The desctext event attribute will be
assigned the string This string will be overridden initially. These event
attributes are all assigned with the more generic NV390MSG_Event FSS, from which
the NV390MSG_NetView_NCCF FSS follows.<br>
The sub_source event attribute will be assigned the value of NetView NCCF. The
msgnumber event attribute will be assigned the value 002I (which was dissected
from the input message on the first %s* specification). The -temp1 temporary event
attribute will be assigned the string INVALID COMMAND: ’A BAD COMMAND’ (which
was dissected from the input message on the second %s* specification). This
        temporary variable is then used with the<b> PRINTF</b> value specifier to override the
desctext event attribute with the string Got a DSI message: INVALID COMMAND: ’A
BAD COMMAND’.<br> All of the event attributes, with the exception of the -temp1 event attribute, will be
used to build the outgoing EIF event. The classname for the event will be
NV390MSG_NetView_NCCF , the name of the most specifically matched FSS.<br>
For an example of using FSS, refer to the IHSAMFMT sample (message adapter
service or the IHSANFMT sample (confirmed message adapter service) that is
        shipped with the Event/Automation Service.</p>
        <div class="sline"></div>
    <h2><b>Event Receiver Post-CDS Processing</b></h2>
<p>er Post-CDS Processing
For the alert adapter service, confirmed alert adapter service, message adapter
service, and confirmed message adapter service, translation files are used to
translate incoming service-specific data into an EIF event. For the event receiver, a
CDS file will be used to go in the opposite direction (translate an event into a
NetView alert).<br>
To do this, the processing of the CDS file by the event receiver will be modified
slightly from the processing that is done on the file by the alert adapter service or
the confirmed alert adapter service. Syntactically, all of the information that is
discussed in “Class Definition Statement Files” on page 123 is still true for the
event receiver CDS file. The event receiver treats the event that is output by the
CDS file process as a pseudo event; that is, the event is not meant to be sent to an
event server, but rather is parsed for certain specific event attributes that are
encoded into the NMVT.</p>
    <h2><b>Input Attribute List</b></h2>
<p> Attribute List
The incoming EIF event is encoded into an attribute list as described in the
service-specific encoding section later in this chapter. In addition to the
    <b>$CLASSNAME</b> keyword created when the incoming event is parsed, there are
additional keywords created for the input attribute list by the event receiver. The
following list describes the additional keywords:</p>
    <table>
        <tr>
            <th>Keyword</th>
            <th>Description</th>
            <th>Default</th>
        </tr>
        <tr>
            <td>$NMVT_TYPE</td>
            <td>The type of the NMVT to be
created (alert or resolution).
This keyword is modified by
the NMVT_TYPE event
attribute. The NMVT_TYPE
event attribute can have a
value of ALERT or
RESOLVE.</td>
            <td>ALERT</td>
        </tr>
        <tr>
            <td>$CDS_GROUP</td>
            <td>This keyword contains
values in the set GROUP001, GROUP002, ... GROUP999. The
value of the CONTINUE
event attribute is used to set
the value of this keyword.
For more information about
the $CDS_GROUP keyword
and the CONTINUE event
attribute, see “Matching
Multiple CDSs to Create the
Pseudo Event” on page 147.</td>
            <td>GROUP001</td>
        </tr>
        <tr>
            <td>$BUILD_SV31LIST</td>
            <td>Assigned the value of the
BUILD_SV31LIST event
attribute. This event attribute
can have a value of NO or
YES. When the alert is built,
the value of this keyword is
used to determine whether
subvector 31s are to be
added for each event
attribute/value pair in the
original EIF event. For more
information about the
$BUILD_SV31LIST keyword
and the BUILD_SV31LIST
event attribute, see “Building
the SV 31s Containing the
Original Event” on page 151.</td>
            <td>YES</td>
        </tr>
    </table>
    <h2><b>Output Pseudo Event</b></h2>
    <p class="pad">Like any EIF event, this pseudo event contains a class name, followed by event
attribute/value pairs. Note that because this event will never be sent to a console,
        there is no <b>.baroc</b> file on any console server that corresponds to these events. In
general, a CDS file enables any event attribute/value pair and any class name to
be put into the pseudo event. Even though any class name and event
attribute/value pair can be placed in the pseudo event, the event receiver only
uses certain predefined event attribute names to translate the event into an alert.
Any other event attributes are ignored.</p>
    <h3><b>Pseudo Event Class name</b></h3>
    <p>Pseudo Event Class name
The event receiver does not use the pseudo event class name for translating the
EIF event. All of the CDSs in the event receiver CDS file can have the same name;
however, for ease of organizing the various CDSs and debugging, it is
recommended that you use a different class name for each CDS in the CDS file.
The convention used in the sample CDS file shipped with the E/AS is to group the
CDSs that are associated with producing a particular subvector within the NMVT together and prefacing them with a common character string. The end of the class
name can then have some unique designation to make it unique.<br>
An example:<br>
CLASS SV05_1<br>
...<br>
END<br>
CLASS SV05_2<br>
...<br>
END<br>
CLASS SV05_3<br>
...<br><br>
END<br>
...<br>
In this example, the SELECT segments (not shown) in each CDS statement will
cause a different subvector 05 to be built. The class name for the SV 05 that is
eventually built will have a unique name that identifies it as an SV 05. Again, this
information is used only for visual organization and debugging.</p>
    <h3><b>NMVT_TYPE event attribute</b></h3>
    <p>You can specify the type of NMVT, whether it is an alert or a resolution, by coding
the NMVT_TYPE event attribute in the MAP segment of a CDS. There are two
valid values for this event attribute: RESOLVE and ALERT. The value of this
        event attribute is copied to the <b>$NMVT_TYPE</b> keyword.</p>
    <h3><b>SV event attribute</b></h3>
    <p>This event attribute is the main vehicle for creating the subvectors that are to be
placed into the NMVT.<br> The event attribute name must be prefixed with SV; the rest of the event attribute
name can be any character string. SV05, SVAA and SVNONSENSE are all recognized as
SV event attributes. Again, for clarity and debugging, it is recommended that the
event attribute names contain the number of the subvector being created -- SV05,
SV92, SV05_1.<br>
An SV event attribute value contains the full subvector (including the length and
subvector key). The values that are assigned to SV event attributes in the MAP
segment of a CDS are interpreted as character strings; the event receiver will
decode the numeric character string into the hexadecimal values that are to be
used in the alert. An example of a subvector event attribute from the sample CDS
file:<br>
SV05 = "0B0509100004E3C5C30040";<br>
The value in the SV05 is a character string with hexadecimal characters. The event
receiver translates this character string into true numeric format for inclusion in the
NMVT. The event receiver does not validate this subvector. The subvector that is
placed into the NMVT is similar to the following:<br>
0B0509100004E3C5C30040<br>
Following the general CDS file syntax, if the event attribute value contains only the
digits in the range of 0–9, the value must be enclosed within double quotations to
be interpreted as a string. The previous example has alphabetic characters
(representing the hexadecimal values A-F) in it, so it was not necessary to enclose</p>
    <h3><b>Disabling Hexadecimal String Translation</b></h3>
    <p>In some cases, you may want to add a character string that is not a hexadecimal
value to the subvector string. As previously described, by default the event
receiver attempts to translate the event attribute value hexadecimal string into
numeric format under the assumption that the string is a sequence of hexadecimal
characters (0–9, A–F). In the previous example, the hexadecimal string E3C5C3 is,
in EBCDIC, TEC.<br>
To specify the string TEC directly within the event attribute value, enclose the string
within <> braces. The braces must have escape characters preceding them; the
escape character is # . Using this convention, for example, the string is as follows:
SV05 = "0B0509100004#<TEC#>0040"<br>
This event attribute value would produce exactly the same NMVT subvector as the
first example, as follows:<br>
0B0509100004E3C5C30040<br>
The braces indicate to the event receiver that the data enclosed within the braces is
not a hexadecimal string number that needs to be converted, but the string is to be
placed directly into the NMVT.</p>
        <h3><b>Using Attribute List Data in the Output Subvector</b></h3>
    <p>Event attributes can be assigned the value of a CDS variable ($V, $N, $F variables),
the value of a keyword, or generic attribute from the attribute list. When using
these variables, it is likely that the value of the variable should not be converted.
Also, it is likely that these variables do not contain the entire coded subvector
entirely within the variable. To handle this, the PRINTF style of MAP statement
assignment is useful.<br>
Extending the SV 05 example introduced previously, assume that the string TEC is
the value of the $V2 variable generated by a SELECT segment. To produce an
identical SV 05 for the NMVT, enter the following:<br>
SV05 = PRINTF("0B0509100004#&lt;%s#&gt;0040", $V2);<br>
        Using the<b> PRINTF </b>syntax, the %s format specifier is substituted with the value of
the $V2 variable, which is TEC. The escaped braces tell the event receiver not to
translate the TEC string into numeric format, and again the following subvector
produced is identical to that produced in the first two examples:<br>
0B0509100004E3C5C30040<br>
Any time you need to assign data that came from the original EIF event to the
output subvector, you will likely need to use the PRINTF syntax with string
translation disabled. However, it is possible that the incoming event has, as an
event attribute value, the string E3C5C3 instead of the string TEC. In this case, use
the following string to produce the desired NMVT subvector:<br>
SV05 = PRINTF("0B0509100004%s0040", $V2);<br>
If you continued to disable the hexadecimal string translation, your output
subvector is similar to the following:
0B0509100004C5F3C3F5C3F30040</p>
    <h3><b>Automatic Subvector/Subfield Length Calculation</b></h3>
    <p>In the initial SV 05 example<br>
SV05 = "0B0509100004E3C5C30040";<br>
The length of the subvector was coded directly into the string. Because there is no
variable information in the subvector, the length is coded directly into the event
attribute value within the CDS MAP segment. The length of the subvector might
not be known when the CDS file is created if variable data is used.<br>
Consider the following example that inserts attribute list data into the subvector:
SV05 = PRINTF("0B0509100004#&lt;%s#&gt;0040", $V2);<br>
In this example, the value of the $V2 variable was TEC; therefore, it has a length of
3. This was used to calculate the total subvector length (0B), the subfield 10 length
(09), and the resource name length (04). In reality, the length of the value of the
$V2 variable will be unknown until the event arrives.<br>
To enable the event receiver to calculate the length of a portion of the subvector
string, use curly braces {} around that portion of the string. The curly braces must
be escaped with the escape character #. The curly braces are removed from the
string when the length is calculated, but the opening curly brace is the place
holder in the subvector string for the length field.<br>
Modify the previous example as follows:<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0040#}#}", $V2);<br>
        Following is a step-by-step translation of this event attribute. The <b>PRINTF</b>
substitution is first as follows:<br>
SV05 = "#{05#{1000#{TEC#}0040#}#}";<br>
At this stage, the output subvector is similar to the following:<br>
...E3C5C3...<br>Where the ellipsis represents all data yet to be translated into the subvector. Next,
the segment #{TEC#} is used to calculate the length of the resource name entry. <br>The output subvector is as follows:<br>
...04E3C5C3...<br>
The first #{ is replaced with the length of the segment, the matching #} is
removed. Next, the segment #{100004TEC0040#} is used to calculate the length of
the subfield 10 entry.<br> The output subvector is as follows:<br>
...09100004E3C5C30040<br>
Again, the #{ is replaced with the length of the segment, the matching #} is
removed. Finally, the segment #{05091000100004TEC0040#} is used to calculate the
length of the entire subvector 05.<br>
The final output subvector is as follows:<br>
0B0509100004E3C5C30040</p>
    <h3><b>BUILD_SV31LIST Event Attribute</b></h3>
    <p>The entire original EIF event is, by default, coded into SV 31s and attached to the
NMVT. The class name, each event attribute/value pair, and the END designator
are coded into separate SV 31s. The BUILD_SV31LIST event attribute enables the
user to control whether this list of SV 31s is to be added to the NMVT. When the
pseudo event is completed, if a BUILD_SV31LIST event attribute is present in the
event AND has a value of NO, the SV 31 list is excluded. Otherwise, the SV 31 list
is included.<br>
If any single slot/value pair is larger than what an SV 31 will allow, the slot/value
string is continued in additional SV 31s. The last character of a continued SV 31
will contain a + (plus sign) to indicate that it is continued into the next SV 31. The
+ (plus sign) must be in character position 255 of the SV 31 to signify continuation;
otherwise, the + (plus sign) is interpreted as part of the text message.<br>
Multiple SV 31s will be created in order to continue a slot/value pair, if needed.
Each continued SV 31 will contain a + (plus sign) as the last character. The first
non-continued SV 31 represents the end of the slot/value pair</p>
    <h3><b>CONTINUE Slot</b></h3>
    <p>This event attribute is used to enable the matching of multiple CDSs to create a
single pseudo event. A full description of this multiple pass process on the CDS
file is given in “Matching Multiple CDSs to Create the Pseudo Event” on page 147.
        This event attribute can have a value of either<b> NEXT </b>or<b> GROUPxxx</b>, where xxx is
a value in the range of 000–999.<br>
        The value of this event attribute is used to update the value in the<b> $CDS_GROUP</b>
keyword. This keyword defaults to a value of GROUP001. If the value of a
        CONTINUE event attribute is<b> NEXT,</b> $CDS_GROUP is updated by adding a 1 to
the three numeric digits at the end of the value. If the current value of
$CDS_GROUP is GROUP001, and a CONTINUE event attribute with a value of
        <b>NEXT </b>is encountered in a MAP segment, the new value of the $CDS_GROUP
        keyword will be<b> GROUP001.</b><br> If the value of the CONTINUE event attribute is GROUPxxx, this value is used to
replace the $CDS_GROUP value only if the numeric digits in the event attribute
value are greater than the numeric digits in the current $CDS_GROUP value.
</p>
    <h3><b>SF21 Slot</b></h3>
    <p>This event attribute is used to override the code point in any Subfield 21s that are
in the SV 31s used to send the original EIF event. The value of this event attribute
must be as follows:<br>
attributeName=codepoint<br>
Where attributename is the name of any generic attribute in the input attribute
list, and codepoint is a 2-digit hexadecimal string that defines the value to be
placed in the SF 21 that is associated with the SV31 for the named generic
attribute.<br>
Like the SV event attribute, the SF21 must only be prefixed with the string SF21;
any characters after this prefix are ignored.</p>
    <h3><b>Matching Multiple CDSs to Create the Pseudo Event</b></h3>
    <p>A major difference between the way that CDS files are processed by the event
adapters and how the CDS file is processed by the event receiver is the number of
CDSs that can be matched to produce a single EIF event (or pseudo event, in the
case of the event receiver).</p>
    <h3><b>One-Pass Method</b></h3>
    <p>The event adapters will run through all of the statements in a CDS file until either
one statement is matched or the end of the file is reached without a match. The
MAP segment of that single matching CDS is then used to create the event
attribute/value pairs that will go into the outgoing EIF event.<br>
Although this same one-pass process can be used to create any of the pseudo
events that will be translated into an alert, it can result in a cumbersome CDS file.
To illustrate this, consider the following example.<br>
From an incoming event, create an alert that has various combinations of SV 05s
and SV 92s based on event attribute/value pairs in the event. For the SV 05
creation, you look for the presence of two event attributes -- resource1 and
resource2. The following four CDSs map the SV 05:<br>
CLASS SV05_1<br>
SELECT<br>
1: ATTR(=,resource1);<br>
2: ATTR(=,resource2);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#{#&lt;
        %s#&gt;#}0040#}#}", $V1, $V2);<br>
END<br>
CLASS SV05_2<br>
SELECT<br>
1: ATTR(=,resource1);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#}#}", $V1);<br>
END<br>
CLASS SV05_3<br>
SELECT<br>
1: ATTR(=,resource2);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0040#}#}", $V1);<br>END<br>
CLASS SV05_4<br>
SELECT<br>
1: ATTR(=,$CLASSNAME);<br>
MAP<br>
SV05 = "#{05#{1000#{#&lt;NONE#&gt;#}0084<br>
END<br>
To produce the four different event attributes, different SELECT segments must be
used to inspect for the presence of these event attributes; therefore, there will be 4
different CDSs in the CDS file. Only one of these SV 05s will be in the pseudo
event. The last CDS uses the $CLASSNAME keyword as a default. This keyword
will always be present, so the last CDS will be selected if none of the other CDSs
are matched.<br>
The SV 92 subvector depends on value of another event attribute, severity. There
are three different values for the severity event attribute that can result in
different SV 92s, and a fourth SV 92 that is created if the severity event attribute
contains none of these values. These CDSs are as follows:<br>CLASS SV92_1<br>
SELECT<br>
1: ATTR(=,severity), VALUE(=,FATAL);<br>
MAP<br>
SV92 = "0B92010001FE0300000000"<br>
END<br>
CLASS SV92_2<br>
SELECT<br>
1: ATTR(=,severity), VALUE(=,WARNING);<br>
MAP<br>
SV92 = "0B92010011FE0300000000"<br>
END<br>
CLASS SV92_3<br>
SELECT<br>
1: ATTR(=,severity), VALUE(=,HARMLESS);<br>
MAP<br>
SV92 = "0B92010002FE0300000000"<br>
END<br>
CLASS SV92_4<br>
SELECT<br>
1: ATTR(=,$CLASSNAME);<br>
MAP<br>
SV92 = "0B92010012FE0300000000"<br>
END<br>
Again, this requires 4 different CDSs to produce one and only one of these 4
different event attributes.<br> To produce a single pseudo event that can have any combination of the previous
SV 05s and SV 92s using one pass through the CDS file requires 16 different CDS
statements. The multiplication of the 4 statements needed to produce a unique
SV05 and the 4 statements needed to produce a unique SV 92. Each of the 16 MAP
segments has a single SV 05 and SV 92, representing all of the combinations that
can occur. The four CDSs that represent both resources in combination with the
various SV 92s are:<br>
CLASS SVBOTH_1<br>
SELECT<br>
1: ATTR(=,resource1);<br>
2: ATTR(=,resource2);<br>
3: ATTR(=,severity), VALUE(=,FATAL);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#{#&lt;%s#&gt;#}0040#}#}", $V1, $V2);<br>
SV92 = "0B92010001FE0300000000"<br>
END<br>
CLASS SVBOTH_2<br>
SELECT<br>
1: ATTR(=,resource1);<br>
2: ATTR(=,resource2);<br>
3: ATTR(=,severity), VALUE(=,WARNING);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#{#&lt;%s#&gt;#}0040#}#}", $V1, $V2);<br>
SV92 = "0B92010011FE0300000000"<br>
END<br>
CLASS SVBOTH_3<br>
SELECT<br>
1: ATTR(=,resource1);<br>
2: ATTR(=,resource2);<br>
3: ATTR(=,severity), VALUE(=,HARMLESS);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#{#&lt;%s#&gt;#}0040#}#}", $V1, $V2);<br>
SV92 = "0B92010002FE0300000000"<br>
END<br>CLASS SVBOTH_4<br>
SELECT<br>
1: ATTR(=,resource1);<br>
2: ATTR(=,resource2);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#{#&lt;%s#&gt;#}0040#}#}", $V1, $V2);<br>
SV92 = "0B92010012FE0300000000"<br>
END<br>
When other subvectors that need to be placed in the same output NMVT are
added, the number of needed CDSs and the duplication of event attribute
mappings in the MAP segment grows considerably</p>
    <h3><b>Multiple-Pass Method</b></h3>
    <p>To alleviate this problem, the event receiver makes multiple passes though the CDS
file and collects separate mappings from each segment that it matches for the one
pseudo event that is created. The $CDS_GROUP keyword and the CONTINUE
event attribute are used to control the multiple pass method.<br>
Each pass starts at the beginning of the CDS file. If a CDS is matched that contains
a valid CONTINUE event attribute, at least one more pass will be made through
the CDS file. If a CDS is matched that does not have a CONTINUE statement, or
no CDS is matched, that pass will be the last pass through the CDS file and all of
the event attributes collected to this point are used to create the pseudo event.<br>
        <b>EVERY</b> CDS SELECT segment <b>MUST</b> have one statement that looks for the
$CDS_GROUP keyword to be equal to a string in the range of
GROUP001–GROUP999. By default, the initial value of the $CDS_GROUP keyword
is GROUP001, so the first CDS statement matched must look for this keyword to
be equal to GROUP001.<br>
When a CDS is matched, the CONTINUE event attribute definition in the MAP
segment of that CDS controls whether another pass will be made to match another
CDS. The CONTINUE event attribute will cause the value of the $CDS_GROUP
keyword to change to a specific value (CONTINUE = GROUP004) or to the next
numeric value (CONTINUE = NEXT). If a specific value is given, it must be greater
than the current value of the $CDS_GROUP keyword.<br>
To illustrate the usage of the $CDS_GROUP keyword and the CONTINUE event
attribute, using the previous example, fill in the keyword and event attribute as
follows:<br>CLASS SV05_1<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP001);<br>
2: ATTR(=,resource1);<br>
3: ATTR(=,resource2);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#{#&lt;%s#&gt;#}0040#}#}", $V2, $V3);<br>
CONTINUE = NEXT;<br>
END<br>
CLASS SV05_2<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP001);<br>
2: ATTR(=,resource1);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0084#}#}", $V2);<br>
CONTINUE = NEXT;<br>
END<br>CLASS SV05_3<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP001);<br>
2: ATTR(=,resource2);<br>
MAP<br>
SV05 = PRINTF("#{05#{1000#{#&lt;%s#&gt;#}0040#}#}", $V2);<br>
CONTINUE = NEXT;<br>
END<br>
CLASS SV05_4<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP001);<br>
MAP<br>
SV05_4 = "#{05#{1000#{#&lt;NONE#&gt;#}0084#}#}";<br>
CONTINUE = NEXT;<br>
END<br>
CLASS SV92_1<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP002);<br>
2: ATTR(=,severity), VALUE(=,FATAL);<br>
MAP<br>
SV92 = "0B92010001FE0300000000"<br>
END<br>
CLASS SV92_2<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP002);<br>
2: ATTR(=,severity), VALUE(=,WARNING);<br>
MAP<br>
SV92 = "0B92010011FE0300000000"<br>
END<br>
CLASS SV92_3<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP002);<br>
2: ATTR(=,severity), VALUE(=,HARMLESS);
MAP<br>
SV92 = "0B92010002FE0300000000"<br>
END<br>
CLASS SV92_4<br>SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,GROUP002);<br>
MAP<br>
SV92 = "0B92010012FE0300000000"<br>
END<br>When an EIF event arrives to be translated, the first subvector created is the SV 05
subvector. Because the initial value of the $CDS_GROUP keyword is GROUP001,
the SELECT segments for all of the CDSs that create the SV 05 will look for this
value. If none of the first three CDSs in this group are selected, the fourth will be
selected by default. Because these CDSs define a CONTINUE event attribute with
a value of NEXT, the value of the $CDS_GROUP keyword will be updated to
GROUP002, and another pass will be made through the CDSs to attempt to match
on another CDS.<br>
All of the SV 05 CDSs will now be ignored, because the $CDS_GROUP keyword is
another value. Without this gate, the same SV 05 CDS would continue to be
matched indefinitely. An SV 92 CDS will be matched next. The GROUP002 value
for the $CDS_GROUP keyword determines this. Because none of the SV 92 CDSs
have a CONTIN</p>
    <p>Using the previous CDSs, if an event arrives with event attributes, as follows:<br>
resource1=FIRSTRES<br>
resource2=SECNDRES<br>
severity=WARNING<br>
The following two subvectors will be produced:<br>
1B0519100009C6C9D9E2E3D9C5E2008409E2C5C3D5C4D9C5E20040<br>
0B92010011FE0300000000</p>
    <h3><b>Building the NMVT</b></h3>
    <p>When the pseudo event has been created, the NMVT will be built from data in the
event attributes and keywords</p>
    <h3><b>Building the SV 31s Containing the Original Event</b></h3>
    <p>The $BUILD_SV31LIST keyword indicates whether the SV 31s that contain the
original EIF event data will be built. These SV 31s are added to the NMVT first.
The value of this keyword is modified by the contents of the BUILD_SV31LIST
event attribute.<br>
Each SV 31 contains an element of the original event: the class name, an event
attribute/value pair, or the END designator. Formatted on an NPDA screen, a
simple CDS example follows (assuming that the original event had a class name of
SAMPLE):<br>
ORIGINAL T/EC EVENT:<br>
SAMPLE;<br>
resource1=FIRSTRES;<br>
resource2=SECNDRES;<br>
severity=WARNING;<br>
END</p>
    <h3><b>Overriding the SF21 Codepoint</b></h3>
    <p>Each SV 31 contains an SF 21 subfield. By default, the codepoint associated with
this subfield is X'00'. Two codepoints allow the SV 31 to be associated with the
alert description and probable causes: codepoint X'21' to probable causes, and
codepoint X'22' to alert description. By default, the SV 31 associated with a severity
event attribute is assigned a X'21' codepoint, and the SV 31 associated with a msg
event attribute is assigned a X'22' codepoint.<br>
You can change which SV 31 is associated with the alert description or probable
causes using the SF21 event attribute. This event attribute contains the name of an
attribute from the input attribute list (which must be an event attribute value fromthe incoming EIF event), followed by an equal (=) sign, followed by a one byte
hexadecimal codepoint. For example, if you want to associate an event attribute
called eventdetail from the incoming event with the alert description, code the
following CDS:<br><br>
CLASS SF21_1<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,"GROUP001");<br>
2: ATTR(=,eventdetail);<br>
MAP<br>
SF21_1 = PRINTF("%s=21",$N2);<br>
END<br>
The SF21_1 event attribute value follows:<br>
eventdetail=21<br>
When the SV 31 list is built, the data in the event attribute/value pair named by
eventdetail will be associated with the alert description</p>
    <h3><b>Alert or Resolve</b></h3>
    <p>The value of the $NMVT_TYPE keyword indicates whether the NMVT will be an
alert NMVT (type 0000) or a resolve NMVT (type 0002). This keyword defaults to
an alert NMVT. If the NMVT_TYPE event attribute is set within any matched CDS,
the value of the $NMVT_TYPE keyword is set to this event attribute.</p>
    <h3><b>Adding User Subvectors</b></h3>
    <p>After the SV 31s are added and the NMVT type is determined, the user subvectors
created from CDS MAP segments are added to the NMVT. As previously
mentioned, any event attribute can be assigned a value in the MAP segment of a
CDS statement. The only event attributes that will be used to build user
subvectors, however, must be prefixed with SV.<br> If the same event attribute name is used more than once, the value of the last one
is used as the value of the event attribute. Therefore, if you need multiple
subvectors of the same type, name the event attributes with this subvector data
uniquely. Using SV10 as the event attribute name for more than one SV 10 is not
valid, because all preceding event attributes will be overwritten in the event
        attribute list. Use unique names such as<b> SV10_1, SV10_2,</b> and so forth.<br>
The names for subvector event attributes do not necessarily correspond to the
subvector. The value of an event attribute that you name as SV10_1 can contain
data for a completely different subvector. The value of the subvector event
attribute determines the subvector type, not the name of the event attribute.<br>
The value of a subvector event attribute is decoded as previously described.
Subvectors are added to the NMVT in the order that their defining event attributes
are encountered in the MAP segments.</p>
    <h3><b>Calculating the AlertID for SV 92</b></h3>
    <p>Because the alert ID field must be calculated for the subvector at the time that
NMVT is built, the event receiver will calculate the value for this field of SV 92.
However, you must specify an alert ID place holder in any SV 92 event attributes
that you code in a CDS file. You can put any 4 bytes there; they will be
overwritten by the event receiver. It is recommended that you code four bytes of
        zero (00000000) as the place holder. The event receiver calculates the alert ID as described in <b><i>SNA Formats.</i></b></p>
    <h4><b>Example</b></h4>
    <p>The following example uses the default event receiver service CDS file
(IHSAECDS) provided in the Event/Automation Service.<br>
Assume that the following EIF event was received by the event receiver:<br>
SNA_Performance_Degraded;source=NV390ALT;origin=B3088P2;<br>
sub_origin=TX12/DEV;hostname=USIBMNT.NTVED;adapter_host=NMPIPL06;<br>
date=OCT 29 16:32:52;severity=WARNING;msg=PERFORMANCE DEGRADED:<br>
CONTROLLER;adapter_host_snanode=USIBMNT.NTVED;<br>
event_type=NOTIFICATION;arch_type=GENERIC_ALERT;<br>
product_id=3745;alert_id=00000009;<br>
block_id=’’;action_code=’’;alert_cdpt=4000;<br>
self_def_msg=[ALRTTXT2];event_correl=[N/A];<br>
incident_correl=[N/A];adapter_correl=E7735930A;END<br>The previous event was an alert that was changed into an event by the alert
adapter. All of the event attribute/value pairs are first coded into generic attributes
for the input attribute list; the $CLASSNAME keyword attribute is assigned the
value SNA_Performance_Degraded. <br>The first group in the CDS file is GROUP001; these CDSs determine the NMVT
type. Because there is not a status event attribute in the incoming EIF event, the
NMVT_TYPE event attribute and the $NMVT_TYPE keyword are set to the value
ALERT. Because CONTINUE=NEXT is specified in the MAP segment, the $CDS_GROUP
keyword is set to GROUP002.<br>
The next group in the CDS file defines the SV 93. None of the information in the
original event determines the value of the SV 93; the value of this subvector is as
follows:<br>
0493FE03<br>
CONTINUE=NEXT is specified in the MAP segment. The $CDS_GROUP keyword is set
to GROUP003.<br>
The next group in the CDS file defines the SV 05. The example event will match on
the class SV05_4, it has a host name, origin, and source event attribute, but not a
probe event attribute. After PRINTF and translation, the value of this subvector
follows:<br>
2A052810000EE4E2C9C2D4D5E34BD5E3E5C5C4008408C2F3F0F8F8D7F200F509D5E5F3F9F0C1D3E30040<br>
CONTINUE=NEXT is specified in the MAP segment. The $CDS_GROUP keyword is set
to GROUP004.<br>
The next group in the CDS file defines the SV 10. None of the information in the
original event determines the value of the SV 10; the value of this subvector
follows:<br>
1C10001911040506C7C5D40908F5F6F9F7C2F8F3080FE3C9E5D6D3C9<br>CONTINUE=NEXT is specified in the MAP segment. The $CDS_GROUP keyword is set
to GROUP005.<br>
The next group in the CDS file defines the SV 92. The example event will match on
the class SV92_4, it has severity=WARNING and the $NMVT_TYPE is set to ALERT. The value of this subvector follows:<br>
0B92010011FE0300000000<br>
The alert ID portion of this subvector (the last 4 bytes) will be calculated and filled
in by the event receiver. CONTINUE=NEXT is specified in the MAP segment. The
$CDS_GROUP keyword is set to GROUP006.<br>
The next group in the CDS file defines the SV 97. The example event will match on
the class SV97_1, the $NMVT_TYPE is set to ALERT. The value of this subvector
follows:<br>
0A970881200035003000<br>
CONTINUE=NEXT is specified in the MAP segment. The $CDS_GROUP keyword is set
to GROUP007.<br>The next group in the CDS file defines an SF 21. The example event will match on
the one and only CDS for this group, the msg event attribute is present in the
event. The value of this subfield override follows:<br>
msg=21<br>
CONTINUE=NEXT is specified in the MAP segment. The $CDS_GROUP keyword is set
to GROUP008.<br>
The last group in the CDS file defines another SF 21. The example event will match
on this last CDS, the severity event attribute is present in the event. The value of
this subfield override follows:<br>
severity=22<br>
The $BUILD_SV31LIST keyword is still set to YES. The NMVT built from the
previous process follows:</p>
    <p><b>03D800002B310602028000000512C5D5E40321001B30E2D5C16DD7859986969994819583<br>
856DC4858799818485845E22310602028000000512C5D5E40321001230A296A49983857E<br>
D5E5F3F9F0C1D3E35E4A310602028000000512C5D5E40321003A309699898789957EC2F3<br>
F0F8F8D7F261E2D76BD5C1D761E3D76BC4C5C3D5C5E361E3C5D9D46BD9C1D3E5F461C4C5<br>
E56BE3E7F1F261C4C5E55E26310602028000000512C5D5E40321001630A2A4826D969989<br>
8789957EE3E7F1F261C4C5E55E29310602028000000512C5D5E403210019308896A2A395<br>
8194857EE4E2C9C2D4D5E34BD5E3E5C5C45E28310602028000000512C5D5E40321001830<br>
81848197A385996D8896A2A37ED5D4D7C9D7D3F0F65E27310602028000000512C5D5E403<br>
210017308481A3857ED6C3E340F2F940F1F67AF3F27AF5F25E23310602028000000512C5<br>
D5E40321221330A285A5859989A3A87EE6C1D9D5C9D5C75E36310602028000000512C5D5<br>
E4032121263094A2877ED7C5D9C6D6D9D4C1D5C3C540C4C5C7D9C1C4C5C47AC3D6D5E3D9<br>
D6D3D3C5D95E35310602028000000512C5D5E4032100253081848197A385996D8896A2A3<br>
6DA29581959684857EE4E2C9C2D4D5E34BD5E3E5C5C45E2A310602028000000512C5D5E4<br>
0321001A3085A58595A36DA3A897857ED5D6E3C9C6C9C3C1E3C9D6D55E2A310602028000<br>
000512C5D5E40321001A30819983886DA3A897857EC7C5D5C5D9C9C36DC1D3C5D9E35E22<br>
310602028000000512C5D5E4032100123097999684A483A36D89847EF3F7F4F55E243106<br>
02028000000512C5D5E4032100143081938599A36D89847EF0F0F0F0F0F0F0F95E1E3106<br>
02028000000512C5D5E40321000E3082939683926D89847E7D7D5E213106020280000005<br>
12C5D5E403210011308183A38996956D839684857E7D7D5E22310602028000000512C5D5<br>
E4032100123081938599A36D838497A37EF4F0F0F05E2A310602028000000512C5D5E403<br>
21001A30A28593866D8485866D94A2877EADC1D3D9E3E3E7E3F2BD5E2531060202800000<br>
0512C5D5E4032100153085A58595A36D8396999985937EADD561C1BD5E28310602028000<br>
000512C5D5E4032100183089958389848595A36D8396999985937EADD561C1BD5E2B3106<br>
02028000000512C5D5E40321001B3081848197A385996D8396999985937EC5F7F7F3F5F9<br>
F3F0C15E15310602028000000512C5D5E40321000530C5D5C40493FE032A052810000EE4<br>
E2C9C2D4D5E34BD5E3E5C5C4008408C2F3F0F8F8D7F200F509D5E5F3F9F0C1D3E300401C<br>
10001911040506C7C5D40908F5</b></p>
    <h2><b>Translating ASCII Text Data</b></h2>
    <p>SNMP agents send up data (whether in variable bindings or other parts of the
trap) that is essentially ASCII text data, but the data type in the encoding trap
indicates an octet string. Since the data type is an octet string, the trap-to-alert data
encoding process treats each byte of data as raw hexadecimal data rather than an
encoded character. As a result, the parsing done by the trap-to-alert conversion
task merely turns this data into a character representation of the hex data bytes for
in SELECT criteria in the CDS file. For example, assume the character string ABC
appears in a variable binding value with a type of octet string. Since the data is an
octet string, the data is converted to the character string 414243 and assigned to the
generic keyword associated with the variable binding name.<br>
If you want to use the original ASCII string value of the generic keyword in the
        outgoing alert, the ASCII string 414243 needs to be converted back to the character<br>string <b>ABC</b> and changed to EBCDIC. The $[ and $] escape sequence has been
provided to allow for conversion of the EBCDIC character string 414243 back to
        the EBCDIC character string <b>ABC.</b><br> Within the value encoding, inside the double quotes for the value of the subvector
event attribute (whether in a PRINTF or not), this escape set is used to delimit data
that is considered to be the character representation of hex data that, in turn, is
ASCII character data. Data delimited in this way is turned into EBCDIC character
data and placed within the value of the subvector event attribute. For example, if
you had the following event attribute assignment in a Class Definition Statement:<br>
SV05 = "0B0509100004#[414243#]0040"<br>
The encoding of this event attribute value into an actual hexadecimal alert
subvector would produce:<br>
0B0509100004C1C2C30040<br>
If data within the range delimited by the escape sequences turns out not to be
character representations of hex data that are ASCII characters, then the conversion
to EBCDIC will fail, and the translation of the trap (and thus, building of the
alert/resolve) is terminated and the trap is discarded. Note that if other escape
sequences occur following "#[" and before "#]" is encountered, they are simply
treated as characters that are put into the subvector, which would later fail
conversion to hex then EBCDIC, because they aren't character representations of
hex digits. Also, if "#[" or "#]" occur following the "#&lt;" escape sequence, which
"turns off" translation of character representations of hex digits to hex data in the
subvector, and before "#&gt;", which "restores" that translation mode, then "#[" and
"#]" are simply treated as untranslated character data, and not escape sequences.</p>
    <h2><b>Translating SNMP Non-String Data Types</b></h2>
    <p>Some attributes used in CDS selection are assigned names based upon the places
in the trap from which their values are extracted, while other names are adapted
directly from the trap (for example, variable names, which are object identifiers, in
the variable bindings). The encoded values are all string data, displayable forms of
the data within the trap, and the formats of these strings depend upon the data
types assigned to these pieces of data in the trap.<br>
As an example, suppose that the data type of a value in the trap was found to be
that of an IP address. The trap-to-alert conversion task would turn this into a
string which was the IP address. The following data types can be assigned to data
in an SNMP trap, and the corresponding string to which it is translated.</p>
    <p><b>integer</b></p>
    <p class="pad">signed decimal number string. The integer 30 becomes the EBCDIC string
"30"</p>
    <p><b>null</b>&nbsp;&nbsp;&nbsp;a pair of single quotes in EBCDIC. This becomes the EBCDIC string """.</p>
    <p><b>octet string</b></p>
    <p class="pad">ASN.1 data in dotted decimal notation format. The object 2C010306
becomes the EBCDIC string "1.4.1.3.6".</p>
    <p><b>printable string</b></p>
    <p class="pad">an EBCDIC string</p>
    <p><b> visible string</b></p>
    <p class="pad">an EBCDIC string</p>
    <p><b>general string</b></p>
    <p class="pad">an EBCDIC string</p>
    <p><b>IP address</b></p>
    <p class="pad">IP address. For example, if you are using, dotted decimal notation format,
the address 09080706 becomes the EBCDIC string "9.8.7.6".</p>
    <p><b>counter</b></p>
    <p class="pad">unsigned decimal number string. The number 05 becomes the EBCDIC
string "5".</p>
    <p><b>guage</b>&nbsp;&nbsp;&nbsp;unsigned decimal number string. The number 50 becomes the EBCDIC
string "50".</p>
    <p>The following example uses the default trap-to-alert service CDS file (IHSATCDS)
supplied with the Event/Automation Service. Assume that the following trap data
is received by the trap-to-alert conversion task (words separated for readability).<br>
303B0201 00040670 75626C69 63A42E06<br>
0C2B0601 14011203 01020101 03400449<br>
B5203F02 01050201 00430100 300F300D<br>
06082B06 01120108 07000201 30<br>
Also assume that the IP address and port associated with the agent originating the
trap is 9.50.20.8 and 161, respectively.<br> The trap data is first coded into corresponding keyword and generic attributes for
the input attribute list. The encoded string attributes are:<br>
$ORIGIN_ADDR 9.50.20.8<br>
$ORIGIN_PORT 161<br>
$SNMP_VERSION 0<br>
community public<br>
enterpriseOID<br>
1.3.6.1.20.1.18.3.1.3.1.1.3<br>
agent_address 73.181.32.63<br>
generic_trap 5<br>
specific_trap 0<br>
timestamp 0<br>
1.3.6.1.18.1.8.7.0 30<br>
The first group in the CDS file is GROUP001; this CDS determines the NMVT type
and BUILD_SV31LIST setting. Since this trap is not a Multi-System Manager trap,
the generic formatting done by the CDS file IHSATALL is used. The NMVT_TYPE
event attribute (and therefore, the $NMVT_TYPE keyword) is set to the value
ALERT. The BUILD_SV31LIST event attribute (and therefore, the
$BUILD_SV31LIST keyword) is set to the value YES. Since CONTINUE=NEXT is
specified in the MAP segment, the $CDS_GROUP keyword is set to GROUP002.<br>
The next group in the CDS file defines the SV 92. The value of this subvector is:<br>
0B92080012FE0000000000<br>The Alert ID portion of this subvector (the last 4 bytes) will be calculated and filled
in by the event receiver. CONTINUE=NEXT is specified in the MAP segment, the
$CDS_GROUP keyword is set to GROUP003.<br>
The next group in the CDS file defines the SV 05. After PRINTF and translation,
the value of this subvector is:<br>
22050E100009F7F34BF1F8F14BF300811211000DF7F34BF1F8F14BF3F24BF6F30081<br>
CONTINUE=NEXT is specified in the MAP segment, the $CDS_GROUP keyword
is set to GROUP004.<br>
The next group in the CDS file defines the SV 10. The value of this subvector is:<br>
<b>5A1000281103030000220EE261F3F9F040D78199819393859340C595A3859997<br>
9989A28540E28599A585992F11040804F0F1F0F3F0F01B06E389A596938940D5<br>
    85A3E58985A64086969940D6E261F3F9F00908F5F6F9F7C2F8F2<br></b>
CONTINUE=NEXT is specified in the MAP segment, the $CDS_GROUP keyword
is set to GROUP005.<br>
The next group in the CDS file defines another SV 10, which contains information
about the resource reporting the trap. The value of this subvector is:<br>
<b>2C10000F1109030000090EA495929596A6951A110C0E02F0F0F0F0F0F0F0F0F0<br>
    F0F0F00906A495929596A695<br></b>
CONTINUE=NEXT is specified in the MAP segment, the $CDS_GROUP keyword
is set to GROUP006.<br>
The next group in the CDS file defines the SV 93 and SV 97. The values of these
subvectors are:<br>
0493FE000<br>
A970401210004810000<br>CONTINUE=NEXT is specified in the MAP segment, the $CDS_GROUP keyword
is set to GROUP007.<br>
The last group in the CDS file defines the SV 98. The enterpriseOID, specific trap,
and generic trap values are added as information in this subvector. The value of
this subvector is:<br>
severity=22<br>
The $BUILD_SV31LIST keyword is still set to YES, the actual NMVT built from the
previous process is:<br>
<b>027B000029310602028000000512C5D5E40321001930D6D9C9C7C9D56DC1C4C4D97EF94B<br>
F6F74BF5F04BF1F85E23310602028000000512C5D5E40321001330D6D9C9C7C9D56DD7D6<br>
D9E37EF1F0F3F45E21310602028000000512C5D5E40321001130E2D5D4D76DE5C5D9E2C9<br>
D6D57EF05E29310602028000000512C5D5E4032100193083969494A49589A3A87EF7F0F7<br>
F5F6F2F6C3F6F9F6F35E3C310602028000000512C5D5E40321002C308595A38599979989<br>
A285D6C9C47EF14BF34BF64BF14BF2F04BF14BF1F84BF34BF14BF24BF14BF14BF35E2D31<br>
0602028000000512C5D5E40321001D3081878595A36D8184849985A2A27EF7F34BF1F8F1<br>
4BF3F24BF6F35E21310602028000000512C5D5E40321001130878595859989836DA39981<br>
977EF55E22310602028000000512C5D5E40321001230A2978583898689836DA39981977E<br>
F05E1E310602028000000512C5D5E40321000E30A3899485A2A38194977EF05E28310602<br>
028000000512C5D5E40321001830F14BF34BF64BF14BF1F84BF14BF84BF74BF07EF4F85E<br>
0B92080012FE00331AA4A122050E100009F7F34BF1F8F14BF300811211000DF7F34BF1F8<br>
F14BF3F24BF6F300815A1000281103030000220EE261F3F9F040D78199819393859340C5<br>
95A38599979989A28540E28599A585992F11040804F0F1F0F3F0F01B06E389A596938940<br>
    D585A3E58985A64086969940D6E261F3F9F00908F5F6F9F7C2F8F22C10000F1109030000</b></p>
    <h2><b>Trap-to-Alert Post-CDS P</b></h2>
    <p>The trap-to-alert service post-CDS processing is nearly identical to that used by the
event receiver post-CDS processing. The differences are:</p>
    <ul>
        <li>v There is no $CLASSNAME keyword created by the trap-to-alert service since the
incoming data was not an EIF event.
        </li>
        <li>An additional escape sequence set $[ and $] is available to aid in translating
variable binding data that are ASCII octet strings.</li>
        <li>Unlike EIF event data, SNMP trap data can have a data type other than a
            character string.</li></ul>
        <h2><b>Advanced Customization - Trap-to-Alert Forwarding Daemon</b></h2>
    <p>The way the Event/Automation Service trap-to-alert conversion task receives traps
is through a datagram socket which is bound to a port that you define in the
configuration file (sample member name IHSATCFG). The conventional trap
manager data port number, 162, is the default port.<br>
Since port 162 is a "well-known" port for SNMP managers, and there may be
multiple SNMP manager applications that are interested in trap data, this sort of
port assignment can cause a conflict. To help resolve any conflicts, there is also a
sample datagram forwarding daemon, IHSAUFWD, and an associated sample
configuration file, IHSAUCFG, that are shipped with the Event/Automation
Service. The daemon receives data on a datagram socket and forwards that data to
the destinations given in the configuration file.<br>
Most SNMP agents are set to forward traps to the trap manager at port 162.
IHSAUFWD can use this port to receive the trap data for all interested managers
and then forward this data to the managers. These managers can be on the local
system or at any IP address on the network.<br>
The IHSAUFWD daemon uses a sample configuration file (IHSAUCFG) to specify
the SNMP managers that are to receive the data. A description of the contents of
this configuration file follows:<br>
        <b>comments</b><br>
Comments can be formed by beginning a line with the number sign (#) or
the exclamation point (!).<br>
        <b>host IP address and port<br></b>
To code a destination for the datagram forwarding daemon, put the
following on a line in the file:</p>
    <ul>
        <li>IP address</li>
        <li>white space (one or more blanks)</li>
        <li>port number, in decimal</li>
    </ul>
    <h2><b>Detailed Example for Trap-to-Alert Conversion</b></h2>
    <p>Suppose an SNMP trap is emitted for a managed entity with a problem, and you
want the NetView program to take some action when it appears. A way to do that
is to have the Event/Automation Service receive the trap, convert it to an alert
NMVT, then use NetView automation to process the alert NMVT and take some
action (execute a command).<br>
Generally, you will need to know something about the information the SNMP trap
contains in order to parse the trap and transfer the most useful of the information
to the alert NMVT so that the processing of the alert NMVT will be the most
effective. Documentation associated with the entities emitting the SNMP traps may
contain this kind of information. It may also be obtained by a trace that is active
when the SNMP trap flows, such as the IP data trace of the Event/Automation
Service or a z/OS Communications Server packet trace.<br>
Knowing what information to expect in the SNMP trap, you then create the class
definition statements necessary to extract the interesting information from the trap
and construct the alert NMVT. Of course, if you are also using Multisystem
Manager's IP management functions, you will want to ensure that your new
definitions are integrated so that Multisystem Manager's IP management functions
still work. The class definition statements in this example are designed so that
theycan be placed in sample member IHSATUSR and work with the sample
definitions provided by the NetView program in IHSATCDS and the other
members it includes.<br>
This example starts with an SNMP trap that is emitted for an uninterruptible
power supply problem. The data is shown in hex and has been separated and
annotated to make the trap contents more clear.<br>*<br>
* Outermost constructor for the trap (tag and length)<br>
*<br>
30820127<br>
* SNMP version (00 = SNMPv1)<br>
020100<br><br>
* Community name (public)<br>
04067075626C6963<br><br>
* Trap PDU<br>
A4820118<br>
* Enterprise object ID (1.3.6.1.4.1.12270)<br>
06072B06010401DF6E<br>
* Agent address (10.71.225.20)<br>
40040A47E114<br>
* Generic trap code (6 = enterprise specific)<br>
020106<br>
* Specific trap code (32 in decimal)<br>
020120<br>
* Timeticks<br>
430402A2D49D<br>
* Variable bindings "container"<br>
308200F9<br>
* Variable binding 1<br>
3015<br>
* Variable 1 (1.3.6.1.4.1.12270.200.2.1.1.1)<br>
060D2B06010401DF6E814802010101<br>
* Value 1 (octet string "1493")<br>
040431343933<br>
* Variable binding 2<br>
3019<br>
* Variable 2 (1.3.6.1.4.1.12270.200.2.1.1.2)<br>
060D2B06010401DF6E814802010102<br>
* Value 2 (octet string "/L20/O50")<br>04082F4C32302F4F3530<br>
* Variable binding 3<br>
3024<br>
* Variable 3 (1.3.6.1.4.1.12270.200.2.1.1.3)<br>
060D2B06010401DF6E814802010103<br>
* Value 3 (octet string "2005-01-10T16:13:00")<br>
0413323030352D30312D31305431363A31333A3030<br>
* Variable binding 4<br>
3014<br>
* Variable 4 (1.3.6.1.4.1.12270.200.2.1.1.4)<br>
060D2B06010401DF6E814802010104<br>
* Value 4 (octet string "I14")<br>
0403493134<br>
* Variable binding 5<br>
3025<br>
* Variable 5 (1.3.6.1.4.1.12270.200.2.1.1.5)<br>
060D2B06010401DF6E814802010105<br>
* Value 5 (octet string "DIGIN ON OCCURRED")<br>
0414444947494E204F4E202020204F43435552524544<br>
* Variable binding 6<br>
3015<br>
* Variable 6 (1.3.6.1.4.1.12270.200.2.1.1.6)<br>
060D2B06010401DF6E814802010106<br>
* Value 6 (octet string "DI=1")<br>
040444493D31<br>
* Variable binding 7<br>
3025<br>
* Variable 7 (1.3.6.1.4.1.12270.200.2.1.1.7)<br>
060D2B06010401DF6E814802010107<br>
* Value 7 (octet string "RC2 Gas Status Man. ")<br>
04145243322047617320537461747573204D616E2E20<br>
* Variable binding 8<br>
3011<br>
* Variable 8 (1.3.6.1.4.1.12270.200.2.1.1.8)<br>
060D2B06010401DF6E814802010108<br>
* Value 8 (NULL)<br>
0500<br>
* Variable binding 9<br>
3011<br>
* Variable 9 (1.3.6.1.4.1.12270.200.2.1.1.9)<br>
060D2B06010401DF6E814802010109<br>Knowing that this type of SNMP trap will always contain these variable bindings
and that the values, at least of the interesting variables, will always be the same
kind of data, you can use these class definition statements provide a way to
convert the SNMP trap to an alert NMVT. These sample statements contain
        additional commentary to explain the trap data transferred to the NMVT.<br><b> Note:</b> In the following example, note the following:<br> <ul><li> Because of printing constraints, some of the command lines had to be "broken"
    in order to fit on the page.</li> <li>Use codepage 1047 X'AD' to code a left bracket ( [ ) and codepage 1047 X'BD' to
    code a right bracket ( ] ).</li></ul>
#***********************************************************************<br>
#<br>
# Definitions for catching an SNMP trap indicating a UPS problem<br>
# and turning it into an alert NMVT.<br>
#<br>
# First pass, build subvectors X’92’ (generic alert), X’10’<br>
# product set ID (one each for alert sender and reported resource),<br>
# X’93’ (probable cause), and X’96’ (failure cause).<br># The first pass looks for GROUP001 and a specific trap value<br>
# of 32 (the specific trap value in the trap was converted to<br>
# a string representing the value in decimal).<br>
#***********************************************************************<br>
CLASS IHSATUSR_UPS1<br>
SELECT<br>
1: ATTR(=,$CDS_GROUP), VALUE(=,"GROUP001");<br>
2: ATTR(=,specific_trap), VALUE(=,"32");<br>
MAP<br>
#<br>
# |-- First pass sets desire for alert NMVT<br>
NMVT_TYPE = ALERT;<br>
#<br>
# |-- For this, we don’t want SV x’31’ set<br>
# | We’ll build our own SV x’31’ later<br>
BUILD_SV31LIST = NO;<br>
#<br>
# |-- Alert description code-point<br>
# | I chose X’1501’ LOSS OF EQUIPMENT COOLING<br>
# | to illustrate.<br>
SV92 = "#{92080001150100000000#}";<br>
#<br>
# Hardware and software information for alert builder<br>
# (basically hard-coded and uses our software product name,<br>
# because E/AS is building the alert NMVT)<br>
#<br>
# <b>Note that the line beginning SV10_1 and the line beginning SV10_2 should be<br>
    # coded on continuous lines up to and including the semicolon character</b>
</p>
    <h2><b>Alert-to-Trap Post-CDS Processing</b></h2>
    <p>The alert-to-trap service post-CDS processing converts the EIF event that is
produced from the CDS process into an SNMP trap.<br>
All non-variable binding information in the trap is put into the constructed trap by
the alert-to-trap service directly, without the opportunity to customize it using the
CDS file. The only exception to this is the specific trap value.<br>
The alert-to-trap adapter sets the non-variable binding fields as follows:</p>
    <p><b>version</b></p>
    <p class="pad">0</p>
    <p><b>community</b></p>
    <p class="pad">the value of the community statement from the alert-to-trap configuration
file (IHSAATCF)</p>
    <p><b>enterpriseOID</b></p>
    <p class="pad">the value of the enterpriseOID statement from the alert-to-trap
configuration file</p>
    <p><b>IP address</b></p>
    <p class="pad">the local host IP address</p>
    <p><b>generic type</b></p>
    <p class="pad">0</p>
    <p><b>timestamp</b></p>
    <p class="pad">0</p>
    <p>The specific type is taken from the value of the specific event attribute that is
created by the CDS processing.<br>
All other slot/value pairs are encoded into variable bindings on the trap. If the
name of the slot in the alert-to-trap adapter CDS file is a valid object id, the slot
name is used as the object id in the variable binding and the value of the slot
becomes the value of the variable binding. If the slot name in the CDS file is not a
valid object id, an object id of 1.3.6.1.4.1.2.5.1.4.1.4.x is used for the variable
binding and the value of the variable binding is slot=value, where slot is the CDS
file slot name and value is the CDS file value. The value of x is an index starting at
1 that is increased by one for each variable binding in the trap.<br>
For example, a CDS file MAP statement that maps the slot name
1.3.6.1.4.1.2.5.1.4.1.4.1 to the value examplevalue has a variable binding in the
final trap with an object id of 1.3.6.1.4.1.2.5.1.4.1.4.1 and a value of
examplevalue.<br> A CDS file MAP statement that maps the slot name source to the value examplevalue
has a variable binding in the final trap with an object id of
1.3.6.1.4.1.2.5.1.4.1.4.1 and a value of source=examplevalue. The object id in
this example assumes that there were no other variable bindings that required the
object id to be created by the alert-to-trap adapter, and therefore the starting index
for this object id is 1.
</p>
    <div class="line"></div>
    <h2><b>Chapter 9. NetView Instrumentation</b></h2>
    <p>NetView instrumentation consists of subsystems. The topology display subsystemis available if you have the NetView management console or the Tivoli Business
Service Manager program installed. For any other subsystem, including the event
flow subsystem, the Tivoli Business Service Manager program must be installed.</p>
    <h2><b>Considerations</b></h2>
    <p class="pad">The REXX programs for NetView instrumentation have been compiled with the
ALTERNATE option. If you access the REXX runtime library from NetView, instrumentation REXX programs run in compiled mode. Otherwise, the REXX
alternate library is used and instrumentation REXX programs run in interpreted
mode. If the REXX runtime library or REXX alternate library is not accessible fromthe pageable link pack area (PLPA), you must modify the NetView start procedure
to access one of these libraries.<br>
Events carrying management information to the topology server start as messages
containing keyword/value pairs. These messages issued by the API are BNH351I,
BNH352I, BNH353I, and BNH354I. These messages are converted and forwarded
to a topology server.</p>
    <h2><b>Customization</b></h2>
    <p class="pad">The following samples were updated for application management instrumentation.
        You might need to customize them for your environment.<br><ul><li><b>CNMSTYLE</b><br></li>
Use CNMSTYLE %INCLUDE member CNMSTUSR or CxxSTGEN to add the
DSIAMIAT automation table and the AUTOAMI autotask. Also, copy the
TOWER statement from CNMSTYLE to CNMSTUSR or CxxSTGEN and remove
    the asterisk (*) from the AMI tower.<br> <li><b> DSIAMIAT</b>- in sample DSIPARM</li>
A separate automation table for application management instrumentation. You
need to uncomment one of the following includes:<br> – %INCLUDE DSIAMIR - to route the BNH351-BNH354 messages to another
NetView program. Use this for NetView Version 2 Release 4 and Version 3
Release 1. <br>– %INCLUDE DSIAMIT - to route the BHN351-BNH354 messages to a message
adapter (the Event/Automation Service should be started). You might need to
modify the PPI receiver ID of your Event/Automation Service message
adapter (default is IHSATEC). The message adapter converts and sends the
messages to Tivoli Enterprise Console or Tivoli Netcool/OMNIbus, where
program rules format and send the converted messages to the Tivoli Business
Service Manager program.
Configure the message adapter by including IHSAAPMF in the message
adapter format file. Refer to theIBM Tivoli NetView for z/OS Installation:
Configuring Additional Components for more information.
Configure the Tivoli Enterprise Console event console or Tivoli
Netcool/OMNIbus by importing the files interapp.baroc and interapp_o.rls to
your rules base if they were not previously added by the ihsttec.sh script. See
    the Tivoli Business Service Manager library for more information. <br><li><b>DSIAMII</b>- in sample DSIPARM</li>
Application management instrumentation member<br> – On the focal point NetView (the NetView system that routes messages to the
topology server or message adapter), code the NetView domain of all remote
NetView programs (if any) with the RMTLU=luname keyword.<br> – Customize the monitor default threshold specifications and polling intervals
as appropriate for your environment. Note that the defaults defined here
apply to all instances of a component or connection type. You can change
threshold specifications and polling intervals for a specific instance by
invoking the set threshold or set polling interval tasks.<br>
You can define multiple threshold specifications. Each one consists of three
values. The first value is the threshold value, the second value is the operator, the third value is the severity of the threshold event. For example:<br>
BEGIN_THRESHOLD<br>
SS=Tivoli;TME10NVCNMTAMEL;1.2<br>
MONITOR=(’STATE’UP,6,0,DOWN,6,5 MVR=CNMETDMV 10)<br>
MONITOR=(’IPC QUEUE’ 25,8,2)<br>
MONITOR=(’VIEWMGR QUEUE’ 25,8,2)<br>
MONITOR=(’VSTATMGR QUEUE’ 25,8,2)<br>
END_THRESHOLD<br>
In the example, for the IPC QUEUE monitor, when the current value goes
over (operator 8) 25, a WARNING (2) threshold event is sent.
The meaning of each value is:<br>
1. The threshold value against which the current monitor value is compared.<br>
2. The comparison operator used to compare the current monitor value
against the threshold value:<br>0 = greater than<br>
1 = greater than or equal<br>
2 = less than<br>
3 = less than or equal<br>
4 = equal<br>
5 = not equal<br>
6 = changes to<br>
7 = changes from<br>
8 = goes over<br>
9 = goes less than<br>
10 = matches<br>
11 = does not match<br>
3. The severity of the threshold event to be sent if a match occurs follows:<br>
0 = "NORMAL"<br>
1 = "INFORMATIONAL"<br>
2 = "WARNING"<br>
3 = "SEVERE"<br>
4 = "CRITICAL"<br>
5 = "FATAL" <br>– The following list details what you can customize in DSIAMII to activate one
or all of the components.<br> - Hardware monitor component
INIT=CNME3016(60)<br>
TERM=CNME3017()<br>
The parameter for CNME3016 is the heartbeat_interval. - Event/Automation Service components (message adapter, alert adapter, event receiver)<br>INIT=CNME9503(60 IHSAEVNT.IHSATEC)<br>
TERM=CNME9531()<br>
Change the INIT=CNME9503 statement to include the procname and PPI
receiver ID of your adapters.<br> - MSM agent instrumentation
INIT=FLCAPMIN(60)<br>
TERM=FLCAPMTR()<br>
The parameter for FLCAPMIN is the heartbeat_interval.<br> - Topology display subsystem components. These DSIAMII members have
multiple statements for instrumentation initialization. The statements are as
follows:<br>
INIT=CNMETDIN(HBEAT,60)<br>
INIT=CNMETDIN(QDEPTH,10)<br>
INIT=CNMETDIN(GMFHS,CNMSJH10.C)<br>
INIT=CNMETDIN(GPARM,DOMAIN=CNM01)<br>
INIT=CNMETDIN(RODM,EKGXRODM.X)<br>
INIT=CNMETDIN(COLDPARM,TYPE=COLD,INIT=EKGLISLM)<br>
INIT=CNMETDIN(WARMPARM,TYPE=WARM)<br>
INIT=CNMETDIN(COMPLETE)<br>
The parameters are:<br>
    <li>v HBEAT specifies the heartbeat. It is required</li>
    <li>QDEPTH specifies the queue depth. It is required</li>
    <li>GMFHS specifies the GMFHS startup procedure and its alias. It is
required.</li>
    <li>v GPARM specifies the parameters to be used with the GMFHS start-up
procedure. It is not required but if the domain value is not specified
here, GMFHS will look to find the domain in the initialization member
DUIGINIT or in the specified GMFHS start-up procedure.</li>
    <li>RODM specifies the RODM start-up procedure and its alias. It is
required.</li>
    <li>v COLDPARM specifies the parameters for a RODM start-up procedure
when a user chooses to do a RODM cold start. It is not required.</li>
    <li>WARMPARM specifies the parameters for a RODM start-up procedure
when a user chooses to do a RODM warm start. It is not required.<br>If you create instrumentation, you should modify DSIAMII to add default
threshold specifications and calls to instrumentation initialization and
termination routines. See the Tivoli Business Service Manager library for API
        descriptions.</li></ul>
</p>
    <div class="sline"></div>
    <h2><b>Starting and Stopping Instrumentation</b></h2>
    <p>To start instrumentation, issue the INITAMI command on the focal point NetView(the NetView program that routes messages to the message adapter). INITAMI is
automatically issued on NetView programs defined as remote in DSIAMII. The
INITAMI command starts the AUTOAMI on the focal point of the NetView
program (if not already started). The console identifier for AUTOAMI is set to
AMIxxxxx where xxxxx is the five rightmost characters of the NetView domain.
Therefore, the console will be unique within a sysplex, and the commands issued
from the autotask will correlate.<br>Instrumentation is not, however, forced to run on AUTOAMI. Therefore, in
environments with multiple NetView programs in a system, or in a sysplex, the
INITAMI command should be issued on autotask AUTOAMI.<br>
The INITAMI command also establishes a RMTCMD session with any NetView
system whose domain name is coded on the RMTLU statement in DSIAMII. This
will log on the AUTOAMI autotask on that NetView program.<br>
To stop instrumentation, issue the TERMAMI command. TERMAMI is
automatically issued on NetView programs defined as remote in DSIAMII. In
addition, stop the AUTOAMI autotask on the focal point NetView. This ends the
RMTCMD sessions established by INITAMI.<br>
The topology server can issue instrumentation-related commands after issuing the
TERMAMI command. However, the AUTOAMI autotask must be started for this to
work.
</p>
    <div class="sline"></div>
    <h2><b>Customizing the IBM Tivoli Enterprise Console</b></h2>
    <p>If you route the instrumentation messages to the IBM Tivoli Enterprise Console
through the Event/Automation Service message adapter, you will need to
customize the console.</p>
    <div class="sline"></div>
    <h2><b>ACB Monitor Customization</b></h2>
    <p> Customization
The application control block (ACB) Monitor focal point receives status updates for
ACBs from the focal point Virtual Telecommunications Access Method (VTAM)
and entry point VTAMs. If used in conjunction with the Tivoli Business Service
Manager program, the ACB Monitor discovers the following:</p>
    <ul>
        <li>v generic resources</li>
        <li>user-specified applications,</li>
        <li>v applications matching user-specified models</li>
        <p>The ACB Monitor also monitors the following:</p>
        <li>ACB status</li>
        <li>v session count</li>
        <li>persistent recovery events for ACB applications</li>
    </ul>
    <p>If used in conjunction with the Tivoli Business Service Manager program or with
the NetView management console TN3270 management, the ACB Monitor
discovers TN3270 servers and clients. Optionally, ACB data can be saved in a DB2®
database.
Define one ACB Monitor focal point for each System complex (or sysplex, the set
of z/OS systems). To fully enable instrumentation of application dynamics in a
sysplex environment, define all other images in the sysplex to be entry points of
that focal point.
By saving ACB data in DB2, you can query telnet clients by IP address, host name,
or application name (using the Locate TN3270 Client TBSM tasks). You can also
change your list of critical TN3270 client resources without restarting the ACB
        Monitor. <br><b>Note:</b>1. To save ACB data to DB2, DB2 must be operational on the ACB Monitor focal
point, and the NetView SQL pipe stage must be enabled.<br>
2. The AMI must be enabled on the ACB Monitor focal point to enable the ACB
Monitor instrumentation
</p>
    <h2><b>Parts</b></h2>
    <p class="pad">The parts that are shipped as part of the ACB Monitor are listed in Table 17.<br><i> Table 17. Tivoli Business Service Manager parts list</i>
</p>
    <table>
        <tr>
            <th>Part Name</th>
            <th>Language</th>
            <th>Function</th>
        </tr>
        <tr>
            <td>TN3270.BSDF</td>
            <td>MIF</td>
            <td>TN3270 business system description file</td>
        </tr>
        <tr>
            <td>TN3270.BCDF</td>
            <td>MIF</td>
            <td>TN3270 business component description file</td>
        </tr>
        <tr>
            <td>TN3270.BMDF</td>
            <td>MIF</td>
            <td>TN3270 business mapping description file</td>
        </tr>
        <tr>
            <td>TN3270.CDF</td>
            <td>MIF</td>
            <td>TN3270 component definition file</td>
        </tr>
        <tr>
            <td>Ltn3270loc.ddf</td>
            <td>DDF</td>
            <td>Locate TN3270 client local dialog definition</td>
        </tr>
        <tr>
            <td>Ltn3270glob.ddf </td>
            <td>DDF</td>
            <td>Locate TN3270 client local dialog definition</td>
        </tr>
        <tr>
            <td> TN3270.html</td>
            <td>HTML</td>
            <td>HelpFile</td>
        </tr>
        <tr>
            <td>GENRSC.BSDF</td>
            <td>MIF</td>
            <td>Generic Resources business system description
file</td>
        </tr>
        <tr>
            <td></td>
            <td>MIF</td>
            <td>Generic Resources business system description
file</td>
        </tr>
        <tr>
            <td>GENRSC.BCDF</td>
            <td>MIF</td>
            <td>Generic Resources business system description
file</td>
        </tr>
        <tr>
            <td>GENRSC.BCDF</td>
            <td>MIF</td>
            <td>Generic Resources business system description
file</td>
        </tr>
        <tr>
            <td>GENRSC.CDF</td>
            <td>MIF</td>
            <td>Generic Resources component definition file</td>
        </tr>
        <tr>
            <td>GENRSC.html</td>
            <td>HTML</td>
            <td>Help File</td>
        </tr>
        <tr>
            <td>VTAMAPPL.BSDF</td>
            <td>MIF</td>
            <td>VTAM Application business system
description file</td>
        </tr>
        <tr>
            <td>VTAMAPPL.BCDF</td>
            <td>MIF</td>
            <td>VTAM Application business component
description file</td>
        </tr>
    </table>
    <h2><b>Defining a Focal Point</b></h2>
    <p>To define an ACB Monitor focal point, perform the following steps:<br>
1. Customize the automation table in sample DSIAMIAT. Uncomment the following
include: %INCLUDE CNMSVTFT.<br> 2. Customize the AMI configuration member in sample DSIAMII using the
following steps:<br>
a. Code the NetView domain name of each ACB Monitor entry point on
AMONLU=keyword.<br> b. Do you want to save ACB data to DB2?
    <ul><li>If yes, perform steps 2c and 2d.</li> <li> If no, go to step 2e on page 172.</li></ul><br> c. Code AMONDB2=y. d. Code the DB2 volume on DB2VOL=keyword.<br>e. Code the DB2 volume catalog on DB2VCAT=keyword. f. Code the DB2 buffer pool on DB2BUFFERPOOL=keyword for each predefined<br>
VTAM Application to be monitored.<br>
3. Customize the list of VTAM applications and models to be discovered in
sample DSIAMII as follows:<br>
a. Code the application name on APPLCOMPONENT=applname for each predefined
VTAM application to be monitored.<br>
b. Code the model name on MODELCOMPONENT=modelname for each VTAM model
to be monitored.<br>
4. Do you want to save ACB data to DB2?<br>
    <ul><li>If no, go to step 5.</li> <li> If yes, customize the DB2 parameters in sample DSIAMII by completing the
        following steps:</li></ul>
a. Code AMONDB2=Y.<br> b. Code the DB2 volume on DB2VOL=keyword.<br> c. Code the DB2 volume catalog on DB2VCAT=keyword.<br> d. Code the DB2 buffer pool on DB2BUFFERPOOL=keyword.<br> 5. Customize the default thresholds in sample DSIAMII. You can customize any of
    the following: <br><ul><li> when threshold events are issued for the ACB status monitor</li>
    <li>the severity of the events issued for the ACB status monitor</li>
    <li>the session count monitor</li>
    <li>the persistent recovery monitor</li></ul><br>Customization in DSIAMII defines default thresholds. You can also customize
thresholds for each instance (icon) with the set threshold task.<br>
For example, if you want to change the threshold severity of CONCT and RESET
states to SEVERE (3) rather than INFORMATIONAL (1) for APPLCOMPONENT and
MODELCOMPONENT Applications, change the following line:<br>
ACT,6,0,CONCT,6,1,RESET,6,1,INACT,6,2,UNKNOWN,6,2,PINACT,6,4,PACT,6,4<br>
To:<br>
ACT,6,0,CONCT,6,3,RESET,6,3,INACT,6,2,UNKNOWN,6,2,PINACT,6,4,PACT,6,4<br>
Or, if you want a WARNING threshold event to be issued when session counts
exceed 999, and a NORMAL threshold event when session counts fall below 1000,
change the following line:<br><br>
MONITOR=(’SESSION COUNT’ 0,1,0 EVENT)<br>
To:<br>
MONITOR=(’SESSION COUNT’ 999,8,2,1000,9,0 EVENT)<br>
6. Install the ACB Monitor VTAM exit. Link edit CSECT CNMIETMN into load module
ISTIETMN in the VTAMLIB DD for VTAM.</p>
    <h2><b>Defining an Entry Point</b></h2>
    <p>To define an ACB Monitor entry point, perform the following steps.
1. Customize the automation table in sample DSIAMIAT. Uncomment the following
include: %INCLUDE CNMSVTET
2. Install the ACB Monitor VTAM exit. Linked CSECT CNMIETMN into load module
ISTIETMN in the VTAMLIB DD of VTAM.</p>
    <h2><b>Starting the VTAM ACB Monitor</b></h2>
    <p>Start the AMI by issuing the INITAMI command on the focal point NetView
        system to enable instrumentation for:<br> <ul><li> generic resource</li>
    <li>TN3270 servers</li>
    <li>APPLCOMPONENT VTAM applications</li>
    <li>MODELCOMPONENT VTAM applications</li></ul>
To start the VTAM ACB Monitor, issue the INITAMON command on the focal
point NetView. The focal point and all entry points identified on the
AMONLU=keyword will be activated.<br>
After the VTAM ACB Monitor has been activated, issue the INITAMON
entry_point command, to activate an additional entry point, where entry_point is the
NetView domain name of the entry point.</p>
    <p><b>Recovering a VTAM ACB Monitor Entry Point:</b></p>
    <p>When the RMTCMD LU 6.2 session between an entry point and the focal point
fails, the entry point is automatically stopped. When the error that caused the
communication failure between the two NetView programs has been corrected,
issue the INITAMON entry_point command on the focal point to recover the entry
point.
</p>
    <h2><b>Stopping the VTAM ACB Monitor</b></h2>
    <p>To stop the VTAM ACB Monitor, issue the TERMAMON command on the focal
point NetView. The focal point and all active entry points will be deactivated.<br>
To stop a specific entry point, issue the TERMAMON entry_point command, where
entry_point is the NetView domain name of the entry point. Status for all of the
applications on the VTAM associated with that NetView system will be removed
from the database.</p>
    <div class="line"></div>
    <h2><b>Chapter 10. Designing HTML Files for the NetView Web Server</b></h2>
    <p>The NetView program provides a web application server that accepts commands
through a web browser interface. You can design HTML files for your own web
page.</p>
    <div class="sline"></div>
    <h2><b>Referencing Files and Commands</b></h2>
    <p>Files and Commands
The HTML for accessing the NetView program from the web browser is
dynamically generated at the web application server.<br> The HTML (including user-written HTML) can be divided between the web
application server (workstation) and the NetView for z/OS host. This can include
referencing workstation files from host HTML.</p>
    <h2><b>Understanding the Base URL</b></h2>
    <p>The following is a typical URL when browsing the NetView program:<br>
        <i>https://web_application_server:port/netview/domain_ID/</i><br>
where web_application_server:port is the TCP host name and port number of the
HTTPS server on which the NetView web application is installed, netview is the
NetView web application context root, and domain_ID is the domain ID of the
NetView for z/OS program to which you want to connect.<br>
The URL in the example is considered to be the base URL. If the URL contains a
question mark, any remaining data is considered query data and is not considered
to be part of the base URL.</p>
    <div class="line"></div>
    <h2><b>Appendix A. Color Maps for Hardware Monitor Panels</b></h2>
    <p>lists the panel name, panel number, and color map for hardware monitor
panels. See Chapter 6, “Customizing Hardware Monitor Displayed Data,” on page
77 for more information on color maps.<br>
        <b>Note:</b> Color maps for hardware monitor help and command description panels are
available only in prior releases of the NetView. program. Also, color maps
beginning with BNJMP1 are no longer supported.<br>
        <i>Table 18. Color Maps for Hardware Monitor Panels</i>
</p>
   <img  class="tabl"src="Screenshot%20(49).png">
    <img class="tabl"src="Screenshot%20(50).png">
    <img class="tabl" src="Screenshot%20(51).png">
    <div class="line"></div>
    <h2><b>Appendix B. NetView Macros and Control Blocks</b></h2>
    <p>The macros and control blocks identified in this appendix are provided by the
NetView program as programming interfaces for customers.<br>
Attention: Do not use as programming interfaces any NetView macros other than
those identified in this appendix.</p>
    <h2><b>General-Use Programming Interface Control Blocks and Include Files</b></h2>
    <p>The following control blocks and include files are provided as general-use
programming interfaces.</p>
    <img src="Screenshot%20(52).png" class="tabl">
    <img src="Screenshot%20(53).png" class="tabl">
    <img src="Screenshot%20(54).png" class="tabl">
    <h2><b>>Notices</b></h2>
    <p>This information was developed for products and services offered in the U.S.A.<br>
IBM may not offer the products, services, or features discussed in this document in
other countries. Consult your local IBM representative for information on the
products and services currently available in your area. Any reference to an IBMproduct, program, or service is not intended to state or imply that only that IBMproduct, program, or service may be used. Any functionally equivalent product,
program, or service that does not infringe any IBM intellectual property right may
be used instead. However, it is the user's responsibility to evaluate and verify the
operation of any non-IBM product, program, or service.<br>
IBM may have patents or pending patent applications covering subject matter
described in this document. The furnishing of this document does not give you
any license to these patents. You can send license inquiries, in writing, to:<br>
IBM Director of Licensing<br>
IBM Corporation<br>
North Castle Drive<br>
Armonk, NY 10504-1785<br>
U.S.A.<br>
For license inquiries regarding double-byte (DBCS) information, contact the IBMIntellectual Property Department in your country or send inquiries, in writing, to:<br>
Intellectual Property Licensing<br>
Legal and Intellectual Property Law<br>
IBM Japan, Ltd.<br>
19-21, Nihonbashi-Hakozakicho, Chuo-ku<br>
Tokyo 103-8510, Japan<br>
<b>The following paragraph does not apply to the United Kingdom or any other
    country where such provisions are inconsistent with local law:</b><br>
INTERNATIONAL BUSINESS MACHINES CORPORATION PROVIDES THIS
PUBLICATION "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS
FOR A PARTICULAR PURPOSE.<br>Some states do not allow disclaimer of express or implied warranties in certain
transactions, therefore, this statement might not apply to you.<br>
This information could include technical inaccuracies or typographical errors.
Changes are periodically made to the information herein; these changes will be
incorporated in new editions of the publication. IBM may make improvements
and/or changes in the product(s) and/or the program(s) described in this
publication at any time without notice.<br>
Any references in this information to non-IBM Web sites are provided for
convenience only and do not in any manner serve as an endorsement of those Web sites. The materials at those Web sites are not part of the materials for this IBM
product and use of those Web sites is at your own risk.<br>
IBM may use or distribute any of the information you supply in any way it
believes appropriate without incurring any obligation to you.<br>
Licensees of this program who wish to have information about it for the purpose
of enabling: (i) the exchange of information between independently created
programs and other programs (including this one) and (ii) the mutual use of the
information which has been exchanged, should contact:<br>
IBM Corporation<br>
2Z4A/101<br>
11400 Burnet Road<br>
Austin, TX 78758<br>
U.S.A.<br>
Such information may be available, subject to appropriate terms and conditions,
including in some cases payment of a fee.<br>
The licensed program described in this document and all licensed material
available for it are provided by IBM under terms of the IBM Customer Agreement,
IBM International Program License Agreement or any equivalent agreement
between us.<br>
Information concerning non-IBM products was obtained from the suppliers of
those products, their published announcements or other publicly available sources.
IBM has not tested those products and cannot confirm the accuracy of
performance, compatibility or any other claims related to non-IBM products.
Questions on the capabilities of non-IBM products should be addressed to the
suppliers of those products.<br>COPYRIGHT LICENSE:
This information contains sample application programs in source language, which
illustrate programming techniques on various operating platforms. You may copy, modify, and distribute these sample programs in any form without payment to
IBM, for the purposes of developing, using, marketing or distributing application
programs conforming to the application programming interface for the operating
platform for which the sample programs are written. These examples have not
been thoroughly tested under all conditions. IBM, therefore, cannot guarantee or
imply reliability, serviceability, or function of these programs. You may copy, modify, and distribute these sample programs in any form without payment to
IBM for the purposes of developing, using, marketing, or distributing application
programs conforming to IBM’s application programming interfaces.<br>
Each copy or any portion of these sample programs or any derivative work, must
include a copyright notice as follows:<br>
© (your company name) (year). Portions of this code are derived from IBM Corp.
Sample Programs. © Copyright IBM Corp. _enter the year or years_. All rights
reserved.
</p>
    <div class="sline"></div>
    <h2><b>Programming Interfaces</b></h2>
    <p>This publication documents intended Programming Interfaces that allow the
customer to write programs to obtain the services of Tivoli NetView for z/OS.</p>
    <div class="sline"></div>
    <h2><b>Trademarks</b></h2>
    <p class="pad">IBM, the IBM logo, and ibm.com® are trademarks or registered trademarks of
International Business Machines Corp., registered in many jurisdictions worldwide.
Other product and service names might be trademarks of IBM or other companies.
A current list of IBM trademarks is available on the Web at “Copyright and
trademark information” at http://www.ibm.com/legal/copytrade.shtml .<br> Adobe is a trademark of Adobe Systems Incorporated in the United States, and/or
other countries.<br>
Java and all Java-based trademarks and logos are trademarks or registered
trademarks of Oracle and/or its affiliates.<br>
Linux is a registered trademark of Linus Torvalds in the United States, other
countries, or both.
Microsoft and Windows are trademarks of Microsoft Corporation in the United
States, other countries, or both.<br>
UNIX is a registered trademark of The Open Group in the United States and other
countries.<br>
Other product and service names might be trademarks of IBM or other companies.</p>
    <div class="sline"></div>
    <h2><b>Privacy policy considerations</b></h2>
    <p class="pad">IBM Software products, including software as a service solutions, (“Software
Offerings”) may use cookies or other technologies to collect product usage
information, to help improve the end user experience, to tailor interactions with
the end user or for other purposes. In many cases no personally identifiable
information is collected by the Software Offerings. Some of our Software Offerings
can help enable you to collect personally identifiable information. If this Software
Offering uses cookies to collect personally identifiable information, specific
information about this offering’s use of cookies is set forth below.<br> This Software Offering does not use cookies or other technologies to collect
personally identifiable information.<br>
If the configurations deployed for this Software Offering provide you as customer
the ability to collect personally identifiable information from end users via cookies
and other technologies, you should seek your own legal advice about any laws
applicable to such data collection, including any requirements for notice and
consent.<br>
For more information about the use of various technologies, including cookies, for
these purposes, See IBM’s Privacy Policy at http://www.ibm.com/privacy and
IBM’s Online Privacy Statement at http://www.ibm.com/privacy/details the
section entitled “Cookies, Web Beacons and Other Technologies” and the “IBMSoftware Products and Software-as-a-Service Privacy Statement” at
http://www.ibm.com/software/info/product-privacy. </p>
    <img src="Screenshot%20(55).png" class="abc">
    <img src="Screenshot%20(56).png" class="abc">
        <img src="Screenshot%20(57).png" class="abc">
            <img src="Screenshot%20(58).png" class="abc">
                <img src="Screenshot%20(59).png" class="abc">
                    <img src="Screenshot%20(60).png" class="abc">
    </body>
</html>